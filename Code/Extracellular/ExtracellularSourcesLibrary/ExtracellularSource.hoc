
// !!! remove the underscore in name once we get rid of "create ExtracellularSource"
begintemplate ExtracellularSource_

    public isEqual, checkForUnsupportedIon, packToVec
    public species, spatialInfo, temporalInfo, capacityInfo, seriesInfoOrNil
    public s
    
    external mwh, speciesLibrary
    external stringsEqual, codeContractViolation
    
    strdef species
    // !!! think about storing speciesIdx here
    
    objref spatialInfo, temporalInfo, capacityInfo, seriesInfoOrNil
    
    strdef s
    
    
    proc init() { local numArg localobj nil
        numArg = numarg()
        
        if (numArg < 4 || numArg > 5) {
            codeContractViolation()
        }
        
        species = $s1
        spatialInfo = $o2
        temporalInfo = $o3
        capacityInfo = $o4
        if (numArg == 5) {
            seriesInfoOrNil = $o5
        }
        
        if (spatialInfo.enumPointBall == 0 && temporalInfo.enumStaticSwitchSpike == 1) {
            codeContractViolation()
        }
        // !!! add similar check for enumPointBall+enumStaticSwitchSpike+capacityInfo
        
        if ((temporalInfo.isSeriesOrMinus1 != 1 && seriesInfoOrNil != nil) || (temporalInfo.isSeriesOrMinus1 == 1 && seriesInfoOrNil == nil)) {
            codeContractViolation()
        }
        
        prepareShownString()
    }
    
    func isEqual() { local cond localobj other
        other = $o1
        
        // !!! BUG: it must be illegal to create two sources with the same species, spatialInfo and temporalInfo independently on capacityInfo,
        //     to achieve this, we need to remove the last predicate in "cond" below,
        //     but after doing this, we will face other problem: user cannot click "Correct", change only capacityInfo, then click "Apply"
        
        // !!! maybe it must be illegal to create two sources with the only difference in either startTime, endTime, spikeTime or seriesInfoOrNil
        
        cond = stringsEqual(species, other.species) && spatialInfo.isEqual(other.spatialInfo) && temporalInfo.isEqual(other.temporalInfo) && capacityInfo.isEqual(other.capacityInfo)
        if (!cond) {
            return 0
        }
        if (temporalInfo.isSeriesOrMinus1 != 1) {
            return 1
        }
        return seriesInfoOrNil.isEqual(other.seriesInfoOrNil)
    }
    
    // !!! a temp solution (the list won't show any unsupported ions)
    func checkForUnsupportedIon() { local speciesIdxOrMinus1, isUnsupported
        strdef msg
        speciesIdxOrMinus1 = speciesLibrary.getSpeciesIdxOrMinus1(species)
        isUnsupported = (speciesIdxOrMinus1 == -1)
        if (isUnsupported) {
            sprint(msg, "\"%s\" species.", species)
            mwh.showNotImplementedWarning(msg)
        }
        return isUnsupported
    }
    
    // !!! this will be called from Extracellular module, but Export module will call other one
    obfunc packToVec() { local speciesIdxOrMinus1 localobj vec
        speciesIdxOrMinus1 = speciesLibrary.getSpeciesIdxOrMinus1(species)
        if (speciesIdxOrMinus1 == -1) {
            codeContractViolation()
        }
        
        vec = new Vector()
        vec.append(speciesIdxOrMinus1, spatialInfo.packToVec(), temporalInfo.packToVec(), capacityInfo.packToVec())
        // !!!! no seriesInfoOrNil.packToVec() here by design
        return vec
    }
    
    // All next staff is private
    
    
    // !!! think about showing the temporal info and the capacity info (maybe indicate the capacity just after the species name)
    proc prepareShownString() {
        strdef dynamicsName
        temporalInfo.getDynamicsName(dynamicsName)
        spatialInfo.prepareShownString(species, dynamicsName, temporalInfo.isSeriesOrMinus1, seriesInfoOrNil, s)
    }
    
endtemplate ExtracellularSource_
