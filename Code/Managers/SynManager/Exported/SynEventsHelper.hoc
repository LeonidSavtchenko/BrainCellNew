
begintemplate SynEventsHelper

    public ifMetaVarThenUpdateStatus, createNewSynEventsFilterWatcherButTryToInherit, isSefwEnabled
    public metaVarName, realMechName, realVarType, realVarName, realArrayIndex
    public isMinRPlt1
    
    external smAllComps
    // !! external mth      // !! circular file dependencies problem
    external mcu, enumSynCompIdxs
    external inhomAndStochLibrary
    
    metaMechIdx = -1        // Correspond to FakeMechanism*ForNetCon
    metaVarTypeIdx = -1     //
    strdef metaVarName      //
    metaArrayIndex = -1     //
    
    strdef realMechName     // Correspond to SynEventsFilterWatcher
    realVarType = -1        //
    strdef realVarName      //
    realArrayIndex = -1     //
    
    isMinRPlt1 = -1
    
    objref this
    
    
    proc init() { local metaVarType
        realMechName = "SynEventsFilterWatcher"     // Keep in sync with proc createNewSynEventsFilterWatcherButTryToInherit
        realVarType = 1
        realVarName = "release_probability"
        realArrayIndex = 0
        
        metaMechIdx = 0
        metaVarType = 1
        metaVarTypeIdx = 0  // !! mth.convertVarTypeToVarTypeIdx(metaVarType)
        sprint(metaVarName, "@%s", realVarName)
        metaArrayIndex = 0
    }
    
    proc ifMetaVarThenUpdateStatus() { local minValue
        strdef varName
        varName = $s1
        minValue = $2
        if (mcu.isMetaVar(varName)) {
            isMinRPlt1 = (minValue < 1)
        }
    }
    
    objref _mechStd
    
    proc createNewSynEventsFilterWatcherButTryToInherit() { local wasSefwPresentBefore, is3Or1PartInSynStruc_old, release_probability localobj syn, trgPp, sefwPp, sefwNetCon, nil
    
        syn = $o1
        wasSefwPresentBefore = $2
        is3Or1PartInSynStruc_old = $3
        trgPp = $o4
        
        // Prepare the output point process
        if (wasSefwPresentBefore) {
            sefwPp = syn.sefwPp
        } else {
            _mechStd = smAllComps.o(enumSynCompIdxs.netCon).mechStds[metaMechIdx][metaVarTypeIdx]
            
            // This equals NaN if the var was made inhomogen earlier,
            // but we'll restore all inhomogeneities shortly downstream calling inhomAndStochLibrary.onSynStrucChange
            release_probability = _mechStd.get(metaVarName, metaArrayIndex)
            
            sefwPp = new SynEventsFilterWatcher()     // Keep the name in sync with proc init
            sefwPp.release_probability = release_probability
            // The "seed" will be set shortly downstream (once per rank)
        }
        
        // Prepare the output NetCon
        sefwNetCon = new NetCon(sefwPp, trgPp)
        if (wasSefwPresentBefore) {
            createNewFakeMechStdForNetConAndInFrom(syn.sefwNetCon)
        } else {
            if (is3Or1PartInSynStruc_old) {
                createNewFakeMechStdForNetConAndInFrom(syn.netCon)
            } else {
                // We'll use the _mechStd defined above
            }
        }
        // This inserts NaN-s for inhomogen vars,
        // but we'll restore all inhomogeneities shortly downstream calling inhomAndStochLibrary.onSynStrucChange
        _mechStd.out(sefwNetCon)
        // The second NetCon has no delay
        sefwNetCon.delay = 0
        
        $o5 = sefwPp
        $o6 = sefwNetCon
        
        _mechStd = nil
    }
    
    func isSefwEnabled() {
        if (isMinRPlt1) {
            return 1
        }
        return inhomAndStochLibrary.isAnyStochVarsForSyns()     // Do not move to the IF OR for higher performance
    }
    
    // All next staff is private
    
    
    proc createNewFakeMechStdForNetConAndInFrom() { localobj srcNetCon
        srcNetCon = $o1
        execute("_mechStd = new FakeMechanismStandardForNetCon()", this)        // The template is loaded after this file
        _mechStd.in(srcNetCon)
    }
    
endtemplate SynEventsHelper

objref seh
seh = new SynEventsHelper()
