
begintemplate ReleaseProbabilityHelper

    public ifMetaVarThenEnableOrDisable, createNewOrReuseOldEventFilter
    public isEnabled
    public metaVarName, realMechName, realVarType, realVarName, realArrayIndex
    
    external smAllComps
    // !! external mth      // !! circular file dependencies problem
    external joinStrings
    external mcu, enumSynCompIdxs
    
    metaMechIdx = -1        // Correspond to FakeMechanism*ForNetCon
    metaVarTypeIdx = -1     //
    strdef metaVarName      //
    metaArrayIndex = -1     //
    
    strdef realMechName     // Correspond to PostNetConEventFilter
    realVarType = -1        //
    strdef realVarName      //
    realArrayIndex = -1     //
    
    isEnabled = -1
    
    objref this
    
    
    proc init() { local metaVarType
        realMechName = "PostNetConEventFilter"  // Keep in sync with proc createNewOrReuseOldEventFilter
        realVarType = 1
        realVarName = "release_probability"
        realArrayIndex = 0
        
        metaMechIdx = 0
        metaVarType = 1
        metaVarTypeIdx = 0  // !! mth.convertVarTypeToVarTypeIdx(metaVarType)
        metaVarName = "@"
        joinStrings(metaVarName, realVarName, "")
        metaArrayIndex = 0
    }
    
    proc ifMetaVarThenEnableOrDisable() { local minValue
        strdef varName
        varName = $s1
        minValue = $2
        if (mcu.isMetaVar(varName)) {
            isEnabled = (minValue < 1)
        }
    }
    
    objref _mechStd
    
    proc createNewOrReuseOldEventFilter() { local wasEfPresentBefore, is3Or1PartInSynStruc_old, release_probability localobj syn, trgPp, efPp, efNetCon, nil
    
        syn = $o1
        wasEfPresentBefore = $2
        is3Or1PartInSynStruc_old = $3
        trgPp = $o4
        
        // Prepare the output point process
        if (wasEfPresentBefore) {
            efPp = syn.rpefPp
        } else {
            _mechStd = smAllComps.o(enumSynCompIdxs.netCon).mechStds[metaMechIdx][metaVarTypeIdx]
            
            // This value will be assigned homogeneously in this proc, but if any of the vars must be inhomogeneous, we'll rewrite its values shortly downstream
            release_probability = _mechStd.get(metaVarName, metaArrayIndex)
            
            efPp = new PostNetConEventFilter()  // Keep the name in sync with proc init
            efPp.release_probability = release_probability
            // The "seed" will be set shortly downstream (once per rank)
        }
        
        // Prepare the output NetCon
        efNetCon = new NetCon(efPp, trgPp)
        if (wasEfPresentBefore) {
            execute("_mechStd = new FakeMechanismStandardForNetCon()", this)        // The template is loaded after this one
            _mechStd.in(syn.rpefNetCon)
        } else {
            if (is3Or1PartInSynStruc_old) {
                execute("_mechStd = new FakeMechanismStandardForNetCon()", this)    //
                _mechStd.in(syn.netCon)
            } else {
                // We'll use the _mechStd defined above
                // All values will be assigned homogeneously in this proc, but if any of the vars must be inhomogeneous, we'll rewrite its values shortly downstream
            }
        }
        _mechStd.out(efNetCon)
        efNetCon.delay = 0      // The second NetCon has no delay
        
        $o5 = efPp
        $o6 = efNetCon
        
        _mechStd = nil
    }
    
endtemplate ReleaseProbabilityHelper

objref rph
rph = new ReleaseProbabilityHelper()
