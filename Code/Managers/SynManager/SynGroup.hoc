
// !! some code dupl. with MechComp.hoc

// A group of synapses (a counterpart of MechComp template)
begintemplate SynGroup

    public is3Or1PartInSynStruc, getPpNameOrEmpty, getDistRange, getSecList, applyChangesToLoc, applyChangesToStrucIfNeeded, applyChangesToDirtyHomogenVars, applyInhomogeneityIter, updateStatsCurveIter, updateColormaps, isAnyVarInhom
    public witheredSpineNeckDiam
    
    external msmBaseWidget, spineNeckDiamCache
    external smAllSyns, smAllComps, nanoProximal_ref, nanoDistal_ref
    external mwh, mth, math, mcu, rph, rngUtils
    external stringsEqual, codeContractViolation
    external eachItemInList
    external enumSynCompIdxs, enumSynLoc
    external isScheduledRescanningOfDistMechs
    
    objref randomSynLoc
    objref this
    
    witheredSpineNeckDiam = -1
    
    
    proc init() {
        randomSynLoc = rngUtils.getFor_synLoc()
        
        // We could set 0 here, but it turns out, NEURON resets the diam to 1e-9 when user enters
        //  Tools -> Distributed Mechanisms -> Viewers -> Shape Name
        // and then double clicks on any Spine Neck section in the list.
        witheredSpineNeckDiam = 1e-9
    }
    
    func is3Or1PartInSynStruc() { localobj nil
        // It's a code contract that all the syns have the same structure
        return (smAllSyns.o(0).netCon != nil)
    }
    
    proc getPpNameOrEmpty() { local enumPpRole, idx localobj pp, nil, strFunc
        strdef ppNameWithBrackets, ppName
        
        enumPpRole = $1     // 0: "Source PP", 1: "Target PP", 2: "Single PP"
        
        // It's a code contract that all the syns have the same structure
        pp = smAllSyns.o(0).getPointProcess(enumPpRole)
        if (pp == nil) {
            $s2 = ""
            return
        }
        
        // !! maybe this can be optimized significantly (e.g. with Python) or at least we can extract and call a shared util
        sprint(ppNameWithBrackets, "%s", pp)
        strFunc = new StringFunctions()
        idx = strFunc.head(ppNameWithBrackets, "\\[", ppName)
        if (idx == -1) {
            codeContractViolation()
        }
        
        $s2 = ppName
    }
    
    func getDistRange() { local distMin, distMax, isDisconnected, dist localobj syn
        distMin = math.inf
        distMax = -1
        
        isDisconnected = 0
        for eachItemInList(syn, smAllSyns) {
            dist = syn.dist
            if (dist == 1e20) { // NEURON docs say: If a continuous path does not exist the return value is 1e20
                isDisconnected = 1
                break
            }
            math.updateMinMax(&distMin, &distMax, dist)
        }
        
        if (isDisconnected) {
            return 1
        }
        
        $&1 = distMin
        $&2 = distMax
        
        return 0
    }
    
    obfunc getSecList() { localobj secList, syn
        secList = new SectionList()
        for eachItemInList(syn, smAllSyns) {
            syn.sec_ref.sec secList.append()
        }
        
        // When synapse location is "Dendrite (just under Spine Neck)",
        // this is required to avoid glitchy look of the colormap "Show syn locations only"
        secList.unique()
        
        return secList
    }
    
    proc applyChangesToLoc() { local p, isReviewAfterApply, distMin, distMax, synIdx, connectionPoint, spineNeckDiam localobj sec_ref, syn
        p = $1
        isReviewAfterApply = $2
        
        if (enumSynLoc == 2) {
            randomSynLoc.binomial(1, p)     // Bernoulli distribution
        }
        
        distMin = math.inf
        distMax = -1
        for synIdx = 0, smAllSyns.count() - 1 {
            getNewSecRefConnectionPointAndSpineNeckDiam(synIdx, sec_ref, &connectionPoint, &spineNeckDiam)
            syn = smAllSyns.o(synIdx)
            
            syn.changeLocation(sec_ref, connectionPoint)
            nanoProximal_ref.o(synIdx).sec {
                diam = spineNeckDiam
            }
            
            math.updateMinMax(&distMin, &distMax, syn.dist)
        }
        
        msmBaseWidget.synManagerMainWidget.onSynLocChangedHandler(distMin, distMax, isReviewAfterApply)
        
        isScheduledRescanningOfDistMechs = 1    // !! for higher performance, it would be better to rescan only spine_neck.morphology
    }
    
    func applyChangesToStrucIfNeeded() { local is3Or1PartInSynStruc_new, doesSrcPpRequireSection, isForceNewTrgOrSng, is3Or1PartInSynStruc_old, enumPpRole_old, isSrcMechNameUnchanged, isRpefPresenceUnchanged, isTrgMechNameUnchanged, seed localobj srcMechType, syn, srcPp, trgPp, netCon, rpefPp, rpefNetCon, oldPp, sngPp
        strdef srcMechName, trgMechName, sngMechName, trgOrSngMechName_old, srcMechName_old, trgMechName_old, sngMechName_old
        
        is3Or1PartInSynStruc_new = $1
        srcMechName = $s2
        trgMechName = $s3
        sngMechName = $s4
        doesSrcPpRequireSection = $5
        isForceNewTrgOrSng = $6
        
        is3Or1PartInSynStruc_old = is3Or1PartInSynStruc()
        
        if (is3Or1PartInSynStruc_old) {
            enumPpRole_old = 1
        } else {
            enumPpRole_old = 2
        }
        getPpNameOrEmpty(enumPpRole_old, trgOrSngMechName_old)
        
        if (is3Or1PartInSynStruc_new) {
            getPpNameOrEmpty(0, srcMechName_old)
            getPpNameOrEmpty(1, trgMechName_old)
            isSrcMechNameUnchanged = stringsEqual(srcMechName, srcMechName_old)
            isRpefPresenceUnchanged = (rph.isEnabled == isRpefPresentInSynStruc())
            isTrgMechNameUnchanged = stringsEqual(trgMechName, trgMechName_old)
            if (!isForceNewTrgOrSng && isSrcMechNameUnchanged && isRpefPresenceUnchanged && isTrgMechNameUnchanged) {
                return 0
            }
            srcMechType = mth.getMechType(1)
            srcMechType.select(srcMechName)
            for eachItemInList(syn, smAllSyns) {
                srcPp = createNewOrReuseOldSrcPp(syn, isSrcMechNameUnchanged, doesSrcPpRequireSection, srcMechType, srcMechName)
                trgPp = createNewOrReuseOldTrgOrSngPp(syn, isForceNewTrgOrSng, is3Or1PartInSynStruc_old, trgMechName, trgOrSngMechName_old)
                if (!rph.isEnabled) {
                    netCon = createNewOrReuseOldNetCon(syn, is3Or1PartInSynStruc_old, srcPp, trgPp)
                    syn.changeStructure(srcPp, netCon, trgPp)
                } else {
                    rph.createNewOrReuseOldEventFilter(syn, isRpefPresenceUnchanged, is3Or1PartInSynStruc_old, trgPp, rpefPp, rpefNetCon)
                    netCon = createNewOrReuseOldNetCon(syn, is3Or1PartInSynStruc_old, srcPp, rpefPp)
                    syn.changeStructure(srcPp, netCon, rpefPp, rpefNetCon, trgPp)
                }
            }
            if (rph.isEnabled) {
                // It's enough to set the seed only once per rank (for the last rpefPp in our case)
                seed = rngUtils.getSeedFor_RPH()
                rpefPp.setSeed(seed)
            }
        } else {
            getPpNameOrEmpty(2, sngMechName_old)
            if (!isForceNewTrgOrSng && stringsEqual(sngMechName, sngMechName_old)) {
                return 0
            }
            for eachItemInList(syn, smAllSyns) {
                sngPp = createNewOrReuseOldTrgOrSngPp(syn, isForceNewTrgOrSng, is3Or1PartInSynStruc_old, sngMechName, trgOrSngMechName_old)
                syn.changeStructure(sngPp)
            }
        }
        
        return 1
    }
    
    func applyChangesToDirtyHomogenVars() { local srcMechIdx, trgMechIdx, sngMechIdx, isSmthChanged
        srcMechIdx = $1
        trgMechIdx = $2
        sngMechIdx = $3
        if (is3Or1PartInSynStruc()) {
            isSmthChanged = ifMechDirtyThenApplyHomogenChanges(enumSynCompIdxs.source, srcMechIdx, 0)
            isSmthChanged = ifMechDirtyThenApplyHomogenChanges(enumSynCompIdxs.netCon, 0,         -1) || isSmthChanged
            isSmthChanged = ifMechDirtyThenApplyHomogenChanges(enumSynCompIdxs.target, trgMechIdx, 1) || isSmthChanged
        } else {
            isSmthChanged = ifMechDirtyThenApplyHomogenChanges(enumSynCompIdxs.single, sngMechIdx, 2)
        }
        return isSmthChanged
    }
    
    iterator applyInhomogeneityIter() { local synIdx localobj distFuncHelper, prevSec_ref, nil, syn
        distFuncHelper = $o2
        
        mwh.showPleaseWaitBox("Applying inhomogeneity.")
        {
            prevSec_ref = nil
            for synIdx = 0, smAllSyns.count() - 1 {
                syn = smAllSyns.o(synIdx)
                if (syn.sec_ref != prevSec_ref) {
                    distFuncHelper.onNewSection()   // For "Zebra (sections)" only
                }
                $o1 = syn
                iterator_statement
                prevSec_ref = syn.sec_ref
            }
        }
        mwh.hidePleaseWaitBox()
    }
    
    iterator updateStatsCurveIter() { local synIdx, y, yMin, yMax localobj syn, graph
        graph = $o2
        yMin = $&4
        yMax = $&5
        for synIdx = 0, smAllSyns.count() - 1 {
            syn = smAllSyns.o(synIdx)
            $o1 = syn
            iterator_statement
            y = $&3
            graph.mark(syn.dist, y, "O", 2, 2, 0)
            math.updateMinMax(&yMin, &yMax, y)
        }
        $&4 = yMin
        $&5 = yMax
    }
    
    proc updateColormaps() { localobj shape1, shape2, syn, pp
        shape1 = $o1
        shape2 = $o2
        
        shape1.point_mark_remove()
        shape2.point_mark_remove()
        for eachItemInList(syn, smAllSyns) {
            pp = syn.getPointProcess(3)
            // !! need to choose the "colorindex" arg according to the watched var value and the colorbar
            shape1.point_mark(pp, 2, 2, 2)
            shape2.point_mark(pp, 2, 2, 2)
        }
    }
    
    func isAnyVarInhom() { local mechIdx, numVarTypes, varTypeIdx localobj comp
        comp = $o1
        mechIdx = $2
        
        numVarTypes = mth.getNumVarTypes(comp.enumDmPpNc)
        for varTypeIdx = 0, numVarTypes - 1 {   // 0: "PARAMETER", 1: "ASSIGNED", 2: "STATE"
            if (comp.isMechVarTypeInhom[mechIdx][varTypeIdx]) {
                return 1
            }
        }
        
        return 0
    }
    
    // All next staff is private
    
    
    obfunc createNewOrReuseOldSrcPp() { local isSrcMechNameUnchanged, doesSrcPpRequireSection localobj syn, srcMechType, outPp
        strdef mechName
        
        syn = $o1
        isSrcMechNameUnchanged = $2
        doesSrcPpRequireSection = $3
        srcMechType = $o4
        mechName = $s5
        
        if (isSrcMechNameUnchanged) {
            return syn.source
        }
        
        if (!doesSrcPpRequireSection) {
            srcMechType.make(outPp)     // Not located in any section
            // !!<rp> do I need to init if from smAllComps.o(*).mechStds[*][*] ?
            return outPp
        } else {
            return createNewPpAttachedToSection(mechName, syn.sec_ref, syn.connectionPoint)
        }
    }
    
    obfunc createNewOrReuseOldTrgOrSngPp() { local isForceNew, is3Or1PartInSynStruc_old localobj syn
        strdef mechName, mechName_old
        
        syn = $o1
        isForceNew = $2
        is3Or1PartInSynStruc_old = $3
        mechName = $s4
        mechName_old = $s5
        
        if (!isForceNew && stringsEqual(mechName, mechName_old)) {
            if (is3Or1PartInSynStruc_old) {
                return syn.target
            } else {
                return syn.single
            }
        } else {
            return createNewPpAttachedToSection(mechName, syn.sec_ref, syn.connectionPoint)
        }
    }
    
    obfunc createNewOrReuseOldNetCon() { local is3Or1PartInSynStruc_old localobj syn, srcPp, nextPp, netCon, mechStd
        syn = $o1
        is3Or1PartInSynStruc_old = $2
        srcPp = $o3
        nextPp = $o4
        
        netCon = new NetCon(srcPp, nextPp)
        if (is3Or1PartInSynStruc_old) {
            mechStd = new FakeMechanismStandardForNetCon()
            mechStd.in(syn.netCon)
            mechStd.out(netCon)
        } else {
            // !!<rp> maybe need to init from smAllComps.o(enumSynCompIdxs.netCon).mechStds[0][0]
        }
        
        return netCon
    }
    
    objref _tempPp
    
    obfunc createNewPpAttachedToSection() { local x localobj sec_ref, outPp, nil
        strdef mechName, hocCommand
        
        mechName = $s1
        sec_ref = $o2
        x = $3
        
        sprint(hocCommand, "_tempPp = new %s(%.15e)", mechName, x)
        sec_ref.sec {
            execute(hocCommand, this)
        }
        
        // !!<rp> do I need to init if from smAllComps.o(*).mechStds[*][*] ?
        
        outPp = _tempPp
        _tempPp = nil
        
        return outPp
    }
    
    func ifMechDirtyThenApplyHomogenChanges() { local compIdx, mechIdx, enumPpRole, isPPorNC, maxVarType, varType, varTypeIdx, varIdx, arraySize, arrayIndex localobj comp, syn, ppOrNetCon, rpefNetConOrNil, nil, compMechStd, tempMechStdExt
        strdef mechName, varName
        
        compIdx = $1
        mechIdx = $2
        enumPpRole = $3
        
        comp = smAllComps.o(compIdx)
        
        if (!comp.isMechDirty[mechIdx]) {
            return 0
        }
        
        isPPorNC = (compIdx != enumSynCompIdxs.netCon)
        
        if (isPPorNC) {
            mth.getMechName(1, mechIdx, mechName)
        }
        for eachItemInList(syn, smAllSyns) {
            if (isPPorNC) {
                ppOrNetCon = syn.getPointProcess(enumPpRole)
                rpefNetConOrNil = nil
                maxVarType = 3
            } else {
                ppOrNetCon = syn.netCon
                if (rph.isEnabled) {
                    rpefNetConOrNil = syn.rpefNetCon
                }
                maxVarType = 1
            }
            for varType = 1, maxVarType {   // 1: "PARAMETER", 2: "ASSIGNED", 3: "STATE"
                varTypeIdx = mth.convertVarTypeToVarTypeIdx(varType)
                compMechStd = comp.mechStds[mechIdx][varTypeIdx]
                if (!comp.isMechVarTypeInhom[mechIdx][varTypeIdx]) {
                    compMechStd.out(ppOrNetCon)
                    if (rpefNetConOrNil != nil) {
                        compMechStd.out(rpefNetConOrNil)
                    }
                } else {
                    if (isPPorNC) {
                        tempMechStdExt = new MechanismStandard(mechName, varType)
                    } else {
                        tempMechStdExt = new FakeMechanismStandardForNetCon()
                    }
                    tempMechStdExt.in(ppOrNetCon)
                    mcu.copyAllVarsValuesExceptInhom(compMechStd, tempMechStdExt)
                    tempMechStdExt.out(ppOrNetCon)
                    if (rpefNetConOrNil != nil) {
                        tempMechStdExt.out(rpefNetConOrNil)
                    }
                }
            }
            if (rpefNetConOrNil != nil) {
                rpefNetConOrNil.delay = 0
            }
        }
        
        comp.isMechDirty[mechIdx] = 0
        
        return 1
    }
    
    // !! code dupl. with Neuron_AddSynapses_reseed
    proc getNewSecRefConnectionPointAndSpineNeckDiam() { local synIdx, synLocIdx, connectionPoint, spineNeckDiam localobj sec_ref, np_ref
        synIdx = $1
        
        if (enumSynLoc == 2) {
            synLocIdx = randomSynLoc.repick()
        } else {
            synLocIdx = enumSynLoc
        }
        
        if (synLocIdx == 0) {
            // Synapse is connected to the centre of spine_head
            connectionPoint = 0.5
            nanoDistal_ref.o(synIdx).sec {
                sec_ref = new SectionRef()
            }
            spineNeckDiam = spineNeckDiamCache.getCachedDiam(synIdx)
        } else if (synLocIdx == 1) {
            // Synapse is connected to the point on dendrite where spine_neck emerges
            np_ref = nanoProximal_ref.o(synIdx)
            np_ref.sec {
                connectionPoint = parent_connection()
            }
            np_ref.parent {
                sec_ref = new SectionRef()
            }
            spineNeckDiam = witheredSpineNeckDiam
        } else {
            codeContractViolation()
        }
        
        $o2 = sec_ref
        $&3 = connectionPoint
        $&4 = spineNeckDiam
    }
    
    func isRpefPresentInSynStruc() { localobj nil
        // It's a code contract that all the syns have the same structure
        return (smAllSyns.o(0).rpefPp != nil)
    }
    
endtemplate SynGroup

synGroup = new SynGroup()
