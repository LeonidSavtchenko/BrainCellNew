
// !!
// BUGs:
//  callers are commented for:
//      * onMechInsert, onMechUninsert
//  implementations are missing or incomplete for:
//      * onNanoReseedOrUpdate (but we already lock the reseeding), onCompSplit, onCompMerge (the last two require changes in the stored VerbatimDistFuncHelper-s)
//  both caller and implementation are missing for:
//      * onRescanInMechManager (if we find out that user has made an inhomogen var homogen, then we need to remove the inhomogen model from this library)
//      * onChangingNsegInMechManager (if nseg was increased for already inhomogen comp, then we need to re-apply all inhomogen models again for this comp;
//          to achieve this, we'll have to store segmentationHelper in MechComp rather than in InhomAndStochTarget)
//      * onMovingDistanceCentre (we need to re-apply all inhomogen models)

// !! maybe create a few specialized iterators to simplify the loops in this template (e.g. eachActiveSpecVarInSyn or eachActiveStochSpecVarInDistMech)

begintemplate InhomAndStochLibrary
    
    public isInhomEnabledFor, isStochEnabledFor, onInhomApply, onStochApply, getInhomModelDataFor, getStochModelDataFor, onMakingVarHomogen, onStochDisable, onNanoReseedOrUpdate
    public isAnyNonVerbatimInhomVarsForDistMechs, getNumInhomVarsForDistMechs, getNumStochVarsForDistMechs, onMechInsert, onMechUninsert, onCompSplit, onCompMerge
    public getNumInhomVarsForSyns, getNumStochVarsForSyns, isAnyStochVarsForSyns, isAnyStochVars, onSynLocChange, onSynStrucChange, restoreToActiveIfWasMadeInactiveOnSynStrucChange
    public doesDistMechHaveAnyStochVars, doesThisVarHaveVerbatimInhomModel, doesAnyInhomVarRequirePython, doesAnyStochVarRequirePython
    
    public activeSpecVars
    
    external mwh, math, dfc, sfc
    external stringsEqual, stringEmpty, concatenateTwoLists, codeContractViolation
    external eachItemInList
    external enumSynCompIdxs
    
    objref activeSpecVars, inactiveSpecVars
    
    
    proc init() { local numArg localobj impRedObj, impActSpecVar
        activeSpecVars = new List()
        inactiveSpecVars = new List()
        
        numArg = numarg()
        if (numArg == 1) {
            // Load data from the imported reduced template
            impRedObj = $o1
            for eachItemInList(impActSpecVar, impRedObj.activeSpecVars) {
                activeSpecVars.append(new InhomAndStochTarget(impActSpecVar))
            }
        } else if (numArg != 0) {
            codeContractViolation()
        }
    }
    
    // in: enumDmPpNc, compIdx, mechIdx, varType, varIdx, arrayIndex
    func isInhomEnabledFor() { localobj actSpecVar, nil
        actSpecVar = findActiveSpecVar($1, $2, $3, $4, $5, $6)
        if (actSpecVar == nil) {
            // Not found
            return 0
        }
        return actSpecVar.isInhom
    }
    
    // in: enumDmPpNc, compIdx, mechIdx, varType, varIdx, arrayIndex
    func isStochEnabledFor() { localobj actSpecVar, nil
        actSpecVar = findActiveSpecVar($1, $2, $3, $4, $5, $6)
        if (actSpecVar == nil) {
            // Not found
            return 0
        }
        return actSpecVar.isStoch
    }
    
    // in: enumDmPpNc, compIdx, mechIdx, varType, varIdx, arrayIndex, segmentationHelper, distFuncHelper, distFuncCatIdx, distFuncIdx
    proc onInhomApply() { localobj actSpecVar
        actSpecVar = findOrCreateActiveSpecVar($1, $2, $3, $4, $5, $6)
        actSpecVar.makeOrUpdateInhom($o7, $o8, $9, $10)
    }
    
    // in: enumDmPpNc, compIdx, mechIdx, varType, varIdx, arrayIndex, boundingHelper, stochFuncHelper, stochFuncCatIdx, stochFuncIdx
    // out: wasStoch
    func onStochApply() { local wasFoundOrCreated, wasStoch localobj actSpecVar
        actSpecVar = findOrCreateActiveSpecVar($1, $2, $3, $4, $5, $6, &wasFoundOrCreated)
        if (wasFoundOrCreated) {
            wasStoch = actSpecVar.isStoch
        } else {
            wasStoch = 0
        }
        actSpecVar.makeOrUpdateStoch($o7, $o8, $9, $10)
        return wasStoch
    }
    
    // in: enumDmPpNc, compIdx, mechIdx, varType, varIdx, arrayIndex
    // out: segmentationHelper, distFuncHelper, distFuncCatIdx, distFuncIdx
    proc getInhomModelDataFor() { localobj actSpecVar, nil
        actSpecVar = findActiveSpecVar($1, $2, $3, $4, $5, $6)
        if (actSpecVar == nil) {
            // Not found
            codeContractViolation()
        }
        if (!actSpecVar.isInhom) {
            codeContractViolation()
        }
        actSpecVar.getInhomModelData($o7, $o8, &$&9, &$&10)
    }
    
    // in: enumDmPpNc, compIdx, mechIdx, varType, varIdx, arrayIndex
    // out: boundingHelper, stochFuncHelper, stochFuncCatIdx, stochFuncIdx
    proc getStochModelDataFor() { localobj actSpecVar, nil
        actSpecVar = findActiveSpecVar($1, $2, $3, $4, $5, $6)
        if (actSpecVar == nil) {
            // Not found
            codeContractViolation()
        }
        if (!actSpecVar.isStoch) {
            codeContractViolation()
        }
        actSpecVar.getStochModelData($o7, $o8, &$&9, &$&10)
    }
    
    // !! major code dupl. with onStochDisable
    // in: enumDmPpNc, compIdx, mechIdx, varType, varIdx, arrayIndex
    proc onMakingVarHomogen() { local idx, isStochDisabledAsWell localobj actSpecVar, nil
        actSpecVar = findActiveSpecVar($1, $2, $3, $4, $5, $6, &idx)
        if (actSpecVar == nil) {
            // Not found
            return
        }
        isStochDisabledAsWell = actSpecVar.disableInhomOrStoch(1)
        if (isStochDisabledAsWell) {
            activeSpecVars.remove(idx)
        }
    }
    
    // !! major code dupl. with onMakingVarHomogen
    // in: enumDmPpNc, compIdx, mechIdx, varType, varIdx, arrayIndex
    // out: wasStoch
    func onStochDisable() { local idx, wasStoch, isInhomDisabledAsWell localobj actSpecVar, nil
        actSpecVar = findActiveSpecVar($1, $2, $3, $4, $5, $6, &idx)
        if (actSpecVar == nil) {
            // Not found
            return 0
        }
        wasStoch = actSpecVar.isStoch
        isInhomDisabledAsWell = actSpecVar.disableInhomOrStoch(0)
        if (isInhomDisabledAsWell) {
            activeSpecVars.remove(idx)
        }
        // !! do I need to restore the old value for the var here (i.e. the value before applying the stochasticity)?
        return wasStoch
    }
    
    // !! implement this method
    proc onNanoReseedOrUpdate() {
        // !! mwh.showNotImplementedWarning()
    }
    
    // !! uncomment the caller for this method once "restoreInhomogeneity" is implemented in InhomAndStochTarget for biophys mechs
    // in: compIdx, mechIdx
    proc onMechInsert() { local compIdx, mechIdx, inactSpecVarIdx localobj newActSpecVars, inactSpecVar, newActSpecVar
        compIdx = $1
        mechIdx = $2
        
        newActSpecVars = new List()
        
        // Given compartment and inserted mechanism, retrieve all old inhom and stoch models of its vars from the storage
        for (inactSpecVarIdx = inactiveSpecVars.count() - 1; inactSpecVarIdx >= 0; inactSpecVarIdx -= 1) {
            inactSpecVar = inactiveSpecVars.o(inactSpecVarIdx)
            if (!inactSpecVar.isDmOrSynPart) {
                continue
            }
            if (inactSpecVar.compIdx != compIdx || inactSpecVar.mechIdx != mechIdx) {
                continue
            }
            
            newActSpecVars.append(inactSpecVar)
            inactiveSpecVars.remove(inactSpecVarIdx)
        }
        
        // Apply all retrieved inhom models
        for eachItemInList(newActSpecVar, newActSpecVars) {
            if (newActSpecVar.isInhom) {
                newActSpecVar.restoreInhomogeneity()    // !! not implemented
            }
        }
        
        // Commit all the changes to the library
        concatenateTwoLists(activeSpecVars, newActSpecVars)
    }
    
    // !! uncomment the caller for this method
    // in: compIdx, mechIdx
    proc onMechUninsert() { local compIdx, mechIdx, actSpecVarIdx localobj actSpecVar
        compIdx = $1
        mechIdx = $2
        
        // Given compartment and uninserted mechanism, move all inhom and stoch models of its vars to the storage
        for (actSpecVarIdx = activeSpecVars.count() - 1; actSpecVarIdx >= 0; actSpecVarIdx -= 1) {
            actSpecVar = activeSpecVars.o(actSpecVarIdx)
            if (!actSpecVar.isDmOrSynPart) {
                continue
            }
            if (actSpecVar.compIdx != compIdx || actSpecVar.mechIdx != mechIdx) {
                continue
            }
            
            inactiveSpecVars.append(actSpecVar)
            activeSpecVars.remove(actSpecVarIdx)
        }
    }
    
    // !! finish the implementation for this method
    // in: splitCompIdx
    proc onCompSplit() { local splitCompIdx
        splitCompIdx = $1
        
        // Correct compIdx everywhere because we've inserted a new comp into mmAllComps
        correctCompIdxsAfterSplit(activeSpecVars, splitCompIdx)
        correctCompIdxsAfterSplit(inactiveSpecVars, splitCompIdx)
        
        // Copy all inhom and stoch models from src (splitCompIdx) to dst (splitCompIdx + 1) comp in activeSpecVars and inactiveSpecVars
        // !!
        
        // Update list_ref for src and dst in activeSpecVars and inactiveSpecVars
        // !!
        
        // !! mwh.showNotImplementedWarning()
    }
    
    // !! finish the implementation for this method
    // in: checkBoxStates, mergeCompIdx
    proc onCompMerge() { local mergeCompIdx, oldNumComps, idx, idx2, delCompIdx localobj checkBoxStates, delCompIdxs, compIdxMapFromOldToNew
        checkBoxStates = $o1
        mergeCompIdx = $2
        
        oldNumComps = checkBoxStates.size()
        
        // Delete inhom and stoch models for all merged comps (both activeSpecVars and inactiveSpecVars)
        delCompIdxs = new Vector()
        for idx = 0, oldNumComps - 1 {
            if (checkBoxStates.x(idx) && idx != mergeCompIdx) {
                delCompIdxs.append(idx)
            }
        }
        /* !!
        print "delCompIdxs:"
        delCompIdxs.printf("%8.4f\n")
        */
        deleteSpecVarsForMergedComps(activeSpecVars, delCompIdxs)
        deleteSpecVarsForMergedComps(inactiveSpecVars, delCompIdxs)
        
        // Correct compIdx everywhere because we've removed some comps in mmAllComps
        compIdxMapFromOldToNew = new Vector(oldNumComps)
        compIdxMapFromOldToNew.indgen()
        for idx = 0, delCompIdxs.size() - 1 {
            delCompIdx = delCompIdxs.x(idx)
            compIdxMapFromOldToNew.x(delCompIdx) = math.nan
            for idx2 = delCompIdx + 1, oldNumComps - 1 {
                compIdxMapFromOldToNew.x(idx2) -= 1
            }
        }
        /* !!
        print "compIdxMapFromOldToNew:"
        compIdxMapFromOldToNew.printf("%8.4f\n")
        */
        correctCompIdxsAfterMerge(activeSpecVars, compIdxMapFromOldToNew)
        correctCompIdxsAfterMerge(inactiveSpecVars, compIdxMapFromOldToNew)
        
        // Update list_ref for mergeCompIdx in activeSpecVars and inactiveSpecVars
        // !!
        
        // Restore inhomogeneity for mergeCompIdx in activeSpecVars
        // !!
        
        // !! mwh.showNotImplementedWarning()
    }
    
    func isAnyNonVerbatimInhomVarsForDistMechs() { local isFound localobj actSpecVar
        isFound = 0
        for eachItemInList(actSpecVar, activeSpecVars) {
            if (actSpecVar.isDmOrSynPart && actSpecVar.isInhom && actSpecVar.distFuncIdx != dfc.verbatimDistFuncIdx) {
                isFound = 1
                break
            }
        }
        return isFound
    }
    
    func getNumInhomVarsForDistMechs() {
        return getNumInhomOrStochVars(1, 1)
    }
    
    func getNumStochVarsForDistMechs() {
        return getNumInhomOrStochVars(1, 0)
    }
    
    func getNumInhomVarsForSyns() {
        return getNumInhomOrStochVars(0, 1)
    }
    
    func getNumStochVarsForSyns() {
        return getNumInhomOrStochVars(0, 0)
    }
    
    func isAnyStochVarsForSyns() { local isFound localobj actSpecVar
        isFound = 0
        for eachItemInList(actSpecVar, activeSpecVars) {
            if (actSpecVar.isDmOrSynPart) {
                continue
            }
            if (actSpecVar.isStoch) {
                // Don't replace with "return 1" because iterators cannot return a value (Segmentation violation)
                isFound = 1
                break
            }
        }
        return isFound
    }
    
    func isAnyStochVars() { local idx
        for idx = 0, activeSpecVars.count() - 1 {
            if (activeSpecVars.o(idx).isStoch) {
                return 1
            }
        }
        return 0
    }
    
    proc onSynLocChange() { localobj actSpecVar
        for eachItemInList(actSpecVar, activeSpecVars) {
            if (actSpecVar.isDmOrSynPart || !actSpecVar.isInhom) {
                continue
            }
            actSpecVar.restoreInhomogeneity()
        }
    }
    
    proc onSynStrucChange() { local isSrcNameUnchanged, isTrgNameUnchanged, isSngNameUnchanged, isNetConPresent_new, isNetConPresenceUnchanged, actSpecVarIdx, actCompIdx, inactSpecVarIdx, inactCompIdx localobj newActSpecVars, newInactSpecVars, actSpecVar, inactSpecVar, newActSpecVar
        strdef srcMechNameOrEmpty_old, trgMechNameOrEmpty_old, sngMechNameOrEmpty_old, srcMechNameOrEmpty_new, trgMechNameOrEmpty_new, sngMechNameOrEmpty_new, inactMechName
        
        srcMechNameOrEmpty_old = $s1
        trgMechNameOrEmpty_old = $s2
        sngMechNameOrEmpty_old = $s3
        srcMechNameOrEmpty_new = $s4
        trgMechNameOrEmpty_new = $s5
        sngMechNameOrEmpty_new = $s6
        
        isSrcNameUnchanged = stringsEqual(srcMechNameOrEmpty_old, srcMechNameOrEmpty_new)
        isTrgNameUnchanged = stringsEqual(trgMechNameOrEmpty_old, trgMechNameOrEmpty_new)
        isSngNameUnchanged = stringsEqual(sngMechNameOrEmpty_old, sngMechNameOrEmpty_new)
        isNetConPresent_new = stringEmpty(sngMechNameOrEmpty_new)
        isNetConPresenceUnchanged = (stringEmpty(sngMechNameOrEmpty_old) == isNetConPresent_new)
        
        newActSpecVars = new List()
        newInactSpecVars = new List()
        
        // For each removed syn part (PP or NetCon), move all inhom and stoch models to the storage
        for (actSpecVarIdx = activeSpecVars.count() - 1; actSpecVarIdx >= 0; actSpecVarIdx -= 1) {
            actSpecVar = activeSpecVars.o(actSpecVarIdx)
            if (actSpecVar.isDmOrSynPart) {
                continue
            }
            
            actCompIdx = actSpecVar.compIdx
            if (actCompIdx == enumSynCompIdxs.srcPp) {
                if (isSrcNameUnchanged) {
                    continue
                }
            } else if (actCompIdx == enumSynCompIdxs.trgPp) {
                if (isTrgNameUnchanged) {
                    continue
                }
            } else if (actCompIdx == enumSynCompIdxs.sngPp) {
                if (isSngNameUnchanged) {
                    continue
                }
            } else if (actCompIdx == enumSynCompIdxs.netCon) {
                if (isNetConPresenceUnchanged) {
                    continue
                }
            } else {
                codeContractViolation()
            }
            
            newInactSpecVars.append(actSpecVar)
            activeSpecVars.remove(actSpecVarIdx)
        }
        
        // For each new syn part (PP or NetCon), try to retrieve the old inhom and stoch models from the storage
        for (inactSpecVarIdx = inactiveSpecVars.count() - 1; inactSpecVarIdx >= 0; inactSpecVarIdx -= 1) {
            inactSpecVar = inactiveSpecVars.o(inactSpecVarIdx)
            if (inactSpecVar.isDmOrSynPart) {
                continue
            }
            
            inactCompIdx = inactSpecVar.compIdx
            inactMechName = inactSpecVar.mechName
            if (inactCompIdx == enumSynCompIdxs.srcPp) {
                if (!stringsEqual(inactMechName, srcMechNameOrEmpty_new)) {
                    continue
                }
            } else if (inactCompIdx == enumSynCompIdxs.trgPp) {
                if (!stringsEqual(inactMechName, trgMechNameOrEmpty_new)) {
                    continue
                }
            } else if (inactCompIdx == enumSynCompIdxs.sngPp) {
                if (!stringsEqual(inactMechName, sngMechNameOrEmpty_new)) {
                    continue
                }
            } else if (inactCompIdx == enumSynCompIdxs.netCon) {
                if (!isNetConPresent_new) {
                    continue
                }
            } else {
                codeContractViolation()
            }
            
            newActSpecVars.append(inactSpecVar)
            inactiveSpecVars.remove(inactSpecVarIdx)
        }
        
        // Apply all retrieved inhom models
        for eachItemInList(newActSpecVar, newActSpecVars) {
            if (newActSpecVar.isInhom) {
                newActSpecVar.restoreInhomogeneity()
            }
        }
        
        // Commit all the changes to the library
        concatenateTwoLists(activeSpecVars, newActSpecVars)
        concatenateTwoLists(inactiveSpecVars, newInactSpecVars)
    }
    
    // in: enumDmPpNc, compIdx, mechIdx, varType, varIdx, arrayIndex
    proc restoreToActiveIfWasMadeInactiveOnSynStrucChange() { local idx localobj inactSpecVar
        for idx = 0, inactiveSpecVars.count() - 1 {
            inactSpecVar = inactiveSpecVars.o(idx)
            if (inactSpecVar.isEqual($1, $2, $3, $4, $5, $6)) {
                break
            }
        }
        if (idx == inactiveSpecVars.count()) {
            // Not found
            return
        }
        activeSpecVars.append(inactSpecVar)
        inactiveSpecVars.remove(idx)
    }
    
    // in: compIdx, mechIdx
    func doesDistMechHaveAnyStochVars() { local isFound localobj actSpecVar
        isFound = 0
        for eachItemInList(actSpecVar, activeSpecVars) {
            if (actSpecVar.isDmOrSynPart && actSpecVar.isStoch && actSpecVar.compIdx == $1 && actSpecVar.mechIdx == $2) {
                // Don't replace with "return 1"
                isFound = 1
                break
            }
        }
        return isFound
    }
    
    // in: enumDmPpNc, compIdx, mechIdx, varType, varIdx, arrayIndex
    func doesThisVarHaveVerbatimInhomModel() { localobj actSpecVar, nil
        actSpecVar = findActiveSpecVar($1, $2, $3, $4, $5, $6)
        if (actSpecVar == nil) {
            // Not found
            return 0
        }
        if (!actSpecVar.isInhom) {
            return 0
        }
        return (actSpecVar.distFuncIdx == dfc.verbatimDistFuncIdx)
    }
    
    func doesAnyInhomVarRequirePython() { local isDmOrSynPart, isExportAssignedAndState, isFound localobj actSpecVar
        isDmOrSynPart = $1
        isExportAssignedAndState = $2
        isFound = 0
        for eachItemInList(actSpecVar, activeSpecVars) {
            // 1: "PARAMETER"
            if (actSpecVar.isInhom && actSpecVar.isDmOrSynPart == isDmOrSynPart && (actSpecVar.varType == 1 || isExportAssignedAndState)) { //
                if (dfc.doesDistFuncRequirePython(actSpecVar.distFuncIdx)) {                                                                // Do not replace with one IF
                    // Don't replace with "return 1"
                    isFound = 1
                    break
                }
            }
        }
        return isFound
    }
    
    func doesAnyStochVarRequirePython() { local isDmOrSynPart, isExportAssignedAndState, isFound localobj actSpecVar
        isDmOrSynPart = $1
        isExportAssignedAndState = $2
        isFound = 0
        for eachItemInList(actSpecVar, activeSpecVars) {
            // 1: "PARAMETER"
            if (actSpecVar.isStoch && actSpecVar.isDmOrSynPart == isDmOrSynPart && (actSpecVar.varType == 1 || isExportAssignedAndState)) { //
                if (sfc.doesStochFuncRequirePython(actSpecVar.stochFuncIdx)) {                                                              // Do not replace with one IF
                    // Don't replace with "return 1"
                    isFound = 1
                    break
                }
            }
        }
        return isFound
    }
    
    // All next staff is private
    
    
    // in: enumDmPpNc, compIdx, mechIdx, varType, varIdx, arrayIndex
    // out: actSpecVarOrNil, (opt) idxOrMinus1
    obfunc findActiveSpecVar() { local numArg, idx localobj actSpecVar, nil
        numArg = numarg()
        if (numArg < 6 || numArg > 7) {
            codeContractViolation()
        }
        
        // Not many activeSpecVars-s, so hashless comparison works just fine
        for idx = 0, activeSpecVars.count() - 1 {
            actSpecVar = activeSpecVars.o(idx)
            if (actSpecVar.isEqual($1, $2, $3, $4, $5, $6)) {
                break
            }
        }
        
        if (idx == activeSpecVars.count()) {
            // Not found
            actSpecVar = nil
            idx = -1
        }
        
        if (numArg == 7) {
            $&7 = idx
        }
        
        return actSpecVar
    }
    
    // in: enumDmPpNc, compIdx, mechIdx, varType, varIdx, arrayIndex
    // out: actSpecVar, (opt) isFoundOrCreated
    obfunc findOrCreateActiveSpecVar() { local numArg, isFound localobj actSpecVar, nil
        numArg = numarg()
        if (numArg < 6 || numArg > 7) {
            codeContractViolation()
        }
        
        actSpecVar = findActiveSpecVar($1, $2, $3, $4, $5, $6)
        isFound = (actSpecVar != nil)
        if (!isFound) {
            actSpecVar = new InhomAndStochTarget($1, $2, $3, $4, $5, $6)
            activeSpecVars.append(actSpecVar)
        }
        
        if (numArg == 7) {
            $&7 = isFound
        }
        
        return actSpecVar
    }
    
    // in: isDmOrSynPart, isInhomOrStoch
    func getNumInhomOrStochVars() { local isDmOrSynPart, isInhomOrStoch, numVars localobj actSpecVar
        isDmOrSynPart = $1
        isInhomOrStoch = $2
        numVars = 0
        for eachItemInList(actSpecVar, activeSpecVars) {
            if (actSpecVar.isDmOrSynPart != isDmOrSynPart) {
                continue
            }
            if (isInhomOrStoch) {
                if (!actSpecVar.isInhom) {
                    continue
                }
            } else {
                if (!actSpecVar.isStoch) {
                    continue
                }
            }
            numVars += 1
        }
        return numVars
    }
    
    proc correctCompIdxsAfterSplit() { local splitCompIdx localobj specVars, specVar
        specVars = $o1
        splitCompIdx = $2
        for eachItemInList(specVar, specVars) {
            if (!specVar.isDmOrSynPart) {
                continue
            }
            if (specVar.compIdx > splitCompIdx) {
                specVar.compIdx += 1
            }
        }
    }
    
    proc deleteSpecVarsForMergedComps() { local specVarIdx localobj specVars, delCompIdxs, specVar
        specVars = $o1
        delCompIdxs = $o2
        for (specVarIdx = specVars.count() - 1; specVarIdx >= 0; specVarIdx -= 1) {
            specVar = specVars.o(specVarIdx)
            if (!specVar.isDmOrSynPart) {
                continue
            }
            if (delCompIdxs.contains(specVar.compIdx)) {
                specVars.remove(specVarIdx)
            }
        }
    }
    
    proc correctCompIdxsAfterMerge() { local oldCompIdx, newCompIdx localobj specVars, compIdxMapFromOldToNew, specVar
        specVars = $o1
        compIdxMapFromOldToNew = $o2
        for eachItemInList(specVar, specVars) {
            if (!specVar.isDmOrSynPart) {
                continue
            }
            oldCompIdx = specVar.compIdx
            newCompIdx = compIdxMapFromOldToNew.x(oldCompIdx)
            specVar.compIdx = newCompIdx
        }
    }
    
endtemplate InhomAndStochLibrary


proc createOrImportInhomAndStochLibrary() { localobj nil
    if (inhomAndStochLibrary == nil) {
        inhomAndStochLibrary = new InhomAndStochLibrary()
    } else {
        if (isBaseOrNanoStart) {
            codeContractViolation()
        }
        // Load data from the imported reduced template
        inhomAndStochLibrary = new InhomAndStochLibrary(inhomAndStochLibrary)
    }
}

createOrImportInhomAndStochLibrary()
