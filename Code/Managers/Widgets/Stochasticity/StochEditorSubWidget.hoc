
begintemplate StochEditorSubWidget

    public show, updateModelCurves, dismissHandler
    public boundingHelper, sampleSize
    
    external msmBaseWidget
    external mwh, math, mth, mmmowb, mcu, inhomAndStochApplicator
    external createEmptyPanel, oneZeroToYesNo, eachPointInGrid, codeContractViolation
    external varsEditorSubWidget
    
    objref mainBox, deck1, deck2, deck3, deck4, deck5, deck6, deck7, deck8, deck9, deck10, graph1, graph2, graph3, graph4, graph5, graph6, graph7, this
    
    objref stochFuncHelpers[20]
    
    objref colourizationHelper, boundingHelper
    
    stochFuncCatIdx = -1
    stochFuncIdx = -1
    double stochFuncIdxs[6]
    specialStochFuncCatIdx = -1
    
    shownCurveIdx = -1
    isShowCdfOrPdf4Model = -1
    isShowCdfOrPdf4Sample = -1
    sampleSize = -1
    numBins = -1
    
    enumDmPpNc = -1
    isMechOrSynEditor = -1
    compIdx = -1
    objref comp
    mechIdx = -1
    strdef mechName
    varType = -1
    varTypeIdx = -1
    varIdx = -1
    strdef varName
    arraySize = -1
    arrayIndex = -1
    strdef varNameWithIndex
    
    isBoundsOK = -1
    isCancel = -1
    
    // !!
    isAltPsdAndAcf = -1
    
    
    proc init() { local inf, isAlreadyEnabled
    
        enumDmPpNc = $1
        compIdx = $2
        mechIdx = $3
        varType = $4
        varIdx = $5
        arrayIndex = $6
        
        isMechOrSynEditor = (enumDmPpNc == 0)
        
        comp = mcu.getComp(isMechOrSynEditor, compIdx)
        mth.getMechName(enumDmPpNc, mechIdx, mechName)
        varTypeIdx = mth.convertVarTypeToVarTypeIdx(varType)
        arraySize = mth.getVarNameAndArraySize(enumDmPpNc, mechIdx, varType, varIdx, varName)
        mth.getVarNameWithIndex(varName, arraySize, arrayIndex, varNameWithIndex)
        
        colourizationHelper = new ColourizationHelper()
        boundingHelper = new BoundingHelper(colourizationHelper)
        
        stochFuncCatIdx = 0
        stochFuncIdx = 1
        specialStochFuncCatIdx = 4
        
        isShowCdfOrPdf4Model = 0
        isShowCdfOrPdf4Sample = 0
        
        sampleSize = 1024
        numBins = 20
        inf = math.inf
        variable_domain(&sampleSize, 2, inf)    // !! need to disallow fractions somehow
        variable_domain(&numBins, 1, inf)       //
        
        stochFuncHelpers[0] = new StochFuncGroupAHelper(0, this)
        stochFuncHelpers[1] = new StochFuncGroupAHelper(1, this)
        stochFuncHelpers[2] = new StochFuncGroupAHelper(2, this)
        stochFuncHelpers[3] = new StochFuncGroupAHelper(3, this)
        stochFuncHelpers[4] = new StochFuncGroupAHelper(4, this)
        stochFuncHelpers[5] = new StochFuncGroupAHelper(5, this)
        stochFuncHelpers[6] = new DistFuncGroupsBDHelper(0, this)                           // v !! just stubs
        stochFuncHelpers[7] = new DistFuncGroupsBDHelper(1, this)
        stochFuncHelpers[10] = new DistFuncGroupsBDHelper(2, this)
        stochFuncHelpers[11] = new DistFuncGroupsBDHelper(3, this)
        stochFuncHelpers[8] = new DistFuncGroupCHelper(stochFuncHelpers[10], this)
        stochFuncHelpers[9] = new DistFuncGroupCHelper(stochFuncHelpers[11], this)
        stochFuncHelpers[12] = new DistFuncGroupsEFHelper(0, this)
        stochFuncHelpers[13] = new DistFuncGroupsEFHelper(1, this, stochFuncHelpers[12])
        stochFuncHelpers[14] = new DistFuncGroupsEFHelper(2, this, stochFuncHelpers[12])    // ^ !! just stubs
        stochFuncHelpers[15] = new StochFuncGroupGHelper(0, this)
        stochFuncHelpers[16] = new StochFuncGroupGHelper(1, this)
        stochFuncHelpers[17] = new StochFuncGroupGHelper(2, this)
        stochFuncHelpers[18] = new StochFuncGroupGHelper(3, this)
        stochFuncHelpers[19] = new StochFuncGroupGHelper(4, this)
        
        isAlreadyEnabled = inhomAndStochApplicator.isStochEnabledFor(compIdx, mechIdx, varType, varIdx, arrayIndex)
        if (isAlreadyEnabled) {
            // !!! need to restore the old UI values for bounding.*, colourizationHelper.*, stochFuncCatIdx, stochFuncIdx, params in distFunc etc.
            //     but this looks more like export/import logic rather than stochasticity logic
            // !!
        }
        
        // !!
        isAltPsdAndAcf = 1
    }
    
    proc show() { local isInhom localobj hBox1, hBox2, hBox3, hBox4, hBox5, hBox6, vBox1, vBox2, vBox3, vBox4
        strdef compName, varTypeName, varNameWithIndex, varNameWithIndexAndUnits, text, yesNo, line2
        
        compName = comp.name
        mth.getVarTypeName(varType, varTypeName)
        mth.getVarNameWithIndex(varName, arraySize, arrayIndex, varNameWithIndex)
        mth.getVarNameWithIndexAndUnits(enumDmPpNc, mechIdx, varName, arraySize, arrayIndex, varNameWithIndexAndUnits)
        isInhom = comp.isMechVarInhom(mechIdx, varTypeIdx, varName, arrayIndex)
        
        mainBox = new VBox()
        mainBox.intercept(1)
        {
            /* !!
            xpanel("")
            xcheckbox("Alt PSD and ACF", &isAltPsdAndAcf)
            xpanel()
            */
            xpanel("")
            mcu.createApplyReminder(isMechOrSynEditor, 0)
            xpanel()
            hBox1 = new HBox()
            hBox1.intercept(1)
            {
                xpanel("")
                mcu.createEditorSubWidgetDigest(enumDmPpNc, compName, mechName, varTypeName, varNameWithIndexAndUnits)
                /* !!! do I need this?
                xlabel("")
                sprint(text, "Distance range for %s:", compName)
                xlabel(text)
                sprint(text, "%g ... %g (%s)", xMin, xMax, units("L"))
                xlabel(text)
                */
                oneZeroToYesNo(isInhom, yesNo)
                sprint(text, "Inhomogeneous: %s", yesNo)
                xlabel(text)
                xpanel()
                vBox1 = new VBox()
                vBox1.intercept(1)
                {
                    xpanel("")
                    xlabel("Bounding:")
                    xpanel()
                    hBox2 = new HBox()
                    hBox2.intercept(1)
                    {
                        vBox2 = new VBox()
                        vBox2.intercept(1)
                        {
                            xpanel("")
                            xradiobutton("Keep as is", "boundingWhereChangedHandler(0)", boundingHelper.where == 0)
                            xradiobutton("Bound from below", "boundingWhereChangedHandler(1)", boundingHelper.where == 1)
                            xradiobutton("Bound from above", "boundingWhereChangedHandler(2)", boundingHelper.where == 2)
                            xradiobutton("Bound on both sides", "boundingWhereChangedHandler(3)", boundingHelper.where == 3)
                            xpanel()
                            deck1 = new Deck()
                            deck1.intercept(1)
                            {
                                createEmptyPanel()
                                xpanel("")
                                xradiobutton("Crop", "boundingModeChangedHandler(0)", boundingHelper.mode == 0)
                                xradiobutton("Re-dice", "boundingModeChangedHandler(1)", boundingHelper.mode == 1)
                                xpanel()
                            }
                            deck1.intercept(0)
                            // deck1.flip_to(*)     // Will be done in boundingWhereChangedHandler below
                            deck1.map()
                            deck2 = new Deck()
                            deck2.intercept(1)
                            {
                                createEmptyPanel()
                                // !! show them as magenta vertical lines on PDF-s and CDF-s; show as horizontal lines on the generated sample
                                xpanel("")
                                xpvalue(boundingHelper.minBoundVarName, &boundingHelper.min, 1, "updateModelCurves()")
                                xpanel()
                                xpanel("")
                                xpvalue(boundingHelper.maxBoundVarName, &boundingHelper.max, 1, "updateModelCurves()")
                                xpanel()
                                xpanel("")
                                xpvalue(boundingHelper.minBoundVarName, &boundingHelper.min, 1, "updateModelCurves()")
                                xpvalue(boundingHelper.maxBoundVarName, &boundingHelper.max, 1, "updateModelCurves()")
                                xpanel()
                            }
                            deck2.intercept(0)
                            // deck2.flip_to(boundingHelper.where)      // Will be done in boundingWhereChangedHandler below
                            deck2.map()
                        }
                        vBox2.intercept(0)
                        vBox2.map()
                        vBox3 = new VBox()
                        vBox3.intercept(1)
                        {
                            deck3 = new Deck()
                            deck3.intercept(1)
                            {
                                xpanel("")
                                xlabel("Keep as is:")
                                sprint(text, "The stochastic component of \"%s\" in %s will not be post-processed.", varNameWithIndex, compName)
                                xlabel(text)
                                xpanel()
                                xpanel("")
                                xlabel("Bound from below:")
                                sprint(line2, "The stochastic component of \"%s\" in %s will be post-processed", varNameWithIndex, compName)
                                xlabel(line2)
                                sprint(text, "to avoid values below \"%s\".", boundingHelper.minBoundVarName)
                                xlabel(text)
                                xpanel()
                                xpanel("")
                                xlabel("Bound from above:")
                                xlabel(line2)
                                sprint(text, "to avoid values above \"%s\".", boundingHelper.maxBoundVarName)
                                xlabel(text)
                                xpanel()
                                xpanel("")
                                xlabel("Bound on both sides:")
                                xlabel(line2)
                                sprint(text, "to avoid values below \"%s\" and above \"%s\".", boundingHelper.minBoundVarName, boundingHelper.maxBoundVarName)
                                xlabel(text)
                                xpanel()
                            }
                            deck3.intercept(0)
                            // deck3.flip_to(boundingHelper.where)      // Will be done in boundingWhereChangedHandler below
                            deck3.map()
                            deck4 = new Deck()
                            deck4.intercept(1)
                            {
                                createEmptyPanel()
                                xpanel("")
                                xlabel("Crop:")
                                xlabel("The random values will be cropped to fit the bound(s).")
                                xlabel("The pros is higher performance.")
                                xlabel("The cons is that PDF has delta-spike(s) at the bound(s).")
                                xpanel()
                                xpanel("")
                                xlabel("Re-dice:")
                                xlabel("The generator will be called repeatedly until it gives a random value that fits the bound(s).")
                                xlabel("(All other values are ignored.)")
                                xlabel("The pros is that PDF doesn't have delta-spike(s) at the bound(s).")
                                xlabel("The cons is lower performance.")
                                xpanel()
                            }
                            deck4.intercept(0)
                            // deck4.flip_to(*)     // Will be done in boundingModeChangedHandler below
                            deck4.map()
                        }
                        vBox3.intercept(0)
                        vBox3.map()
                    }
                    hBox2.intercept(0)
                    hBox2.map()
                }
                vBox1.intercept(0)
                vBox1.map()
            }
            hBox1.intercept(0)
            hBox1.map()
            xpanel("")
            xlabel("Stochastic model:")
            xpanel()
            hBox3 = new HBox()
            hBox3.intercept(1)
            {
                xpanel("")
                xradiobutton("White noise", "noiseChromaticityChangedHandler(0)", colourizationHelper.chromaticity == 0)
                xradiobutton("Coloured noise: PSD ~ 1 / f ^ alpha", "noiseChromaticityChangedHandler(1)", colourizationHelper.chromaticity == 1)
                xpanel()
                deck5 = new Deck()
                deck5.intercept(1)
                {
                    createEmptyPanel()
                    xpanel("")
                    xradiobutton("Pink: alpha = 1 (aka flicker noise)", "noiseColourChangedHandler(0)", colourizationHelper.colour == 0)
                    xradiobutton("Brown: alpha = 2 (aka Brownian noise)", "noiseColourChangedHandler(1)", colourizationHelper.colour == 1)
                    xradiobutton("Blue: alpha = -1 (aka azure noise)", "noiseColourChangedHandler(2)", colourizationHelper.colour == 2)
                    xradiobutton("Purple: alpha = -2 (aka violet noise)", "noiseColourChangedHandler(3)", colourizationHelper.colour == 3)
                    xradiobutton("Custom: alpha in [-2, 2]", "noiseColourChangedHandler(4)", colourizationHelper.colour == 4)
                    xpanel()
                }
                deck5.intercept(0)
                // deck5.flip_to(colourizationHelper.chromaticity)  // Will be done in noiseChromaticityChangedHandler below
                deck5.map()
                deck6 = new Deck()
                deck6.intercept(1)
                {
                    createEmptyPanel()
                    xpanel("")
                    xpvalue("alpha", &colourizationHelper.alpha, 1, "alphaChangedHandler()")
                    xpanel()
                }
                deck6.intercept(0)
                // deck6.flip_to(colourizationHelper.colour)    // Will be done in noiseColourChangedHandler below
                deck6.map()
            }
            hBox3.intercept(0)
            hBox3.map()
            hBox4 = new HBox()
            hBox4.intercept(1)
            {
                vBox4 = new VBox()
                vBox4.intercept(1)
                {
                    xpanel("")
                    xradiobutton("Simple model", "stochFuncCatChangedHandler(0)", stochFuncCatIdx == 0)
                    xradiobutton("Custom expression (one-liner)", "stochFuncCatChangedHandler(1)", stochFuncCatIdx == 1)
                    xradiobutton("Custom function", "stochFuncCatChangedHandler(2)", stochFuncCatIdx == 2)
                    xradiobutton("Table + linear interpolation", "stochFuncCatChangedHandler(3)", stochFuncCatIdx == 3)
                    xradiobutton("Special", "stochFuncCatChangedHandler(4)", stochFuncCatIdx == specialStochFuncCatIdx)
                    xpanel()
                    deck7 = new Deck()
                    deck7.intercept(1)
                    {
                        xpanel("")
                        if (stochFuncCatIdx != 0) {
                            codeContractViolation()
                        }
                        stochFuncIdxs[stochFuncCatIdx] = stochFuncIdx
                        xradiobutton("Uniform", "stochFuncChangedHandler(0)", stochFuncIdx == 0)
                        xradiobutton("Normal", "stochFuncChangedHandler(1)", stochFuncIdx == 1)
                        xradiobutton("Lognormal", "stochFuncChangedHandler(2)", stochFuncIdx == 2)
                        xradiobutton("Negexp", "stochFuncChangedHandler(3)", stochFuncIdx == 3)
                        xradiobutton("Erlang", "stochFuncChangedHandler(4)", stochFuncIdx == 4)
                        xradiobutton("Weibull", "stochFuncChangedHandler(5)", stochFuncIdx == 5)
                        xpanel()
                        hBox5 = new HBox()
                        hBox5.intercept(1)
                        {
                            xpanel("")
                            xradiobutton("Define inverse CDF", "definePdfOrCdfChangedHandler(0)", 1)
                            xradiobutton("Define CDF", "definePdfOrCdfChangedHandler(1)", 0)
                            xradiobutton("Define PDF", "definePdfOrCdfChangedHandler(2)", 0)
                            xpanel()
                            deck8 = new Deck()
                            deck8.intercept(1)
                            {
                                stochFuncIdxs[1] = 6
                                xpanel("")
                                xradiobutton("Enter HOC expression (one-liner)", "stochFuncChangedHandler(6)", 1)
                                xradiobutton("Enter Python expression (one-liner)", "stochFuncChangedHandler(7)", 0)
                                xpanel()
                                stochFuncIdxs[2] = 8
                                xpanel("")
                                xradiobutton("Load HOC function from file", "stochFuncChangedHandler(8)", 1)
                                xradiobutton("Load Python function from file", "stochFuncChangedHandler(9)", 0)
                                xradiobutton("Use already defined/loaded HOC function", "stochFuncChangedHandler(10)", 0)
                                xradiobutton("Use already defined/loaded Python function", "stochFuncChangedHandler(11)", 0)
                                xpanel()
                                stochFuncIdxs[3] = 12
                                xpanel("")
                                xradiobutton("Enter table + linear interpolation", "stochFuncChangedHandler(12)", 1)
                                xradiobutton("Load table from Text file + linear interpolation", "stochFuncChangedHandler(13)", 0)
                                xradiobutton("Load table from Excel file + linear interpolation", "stochFuncChangedHandler(14)", 0)
                                xpanel()
                            }
                            deck8.intercept(0)
                            // deck8.flip_to(*)     // Will be done in stochFuncCatChangedHandler below
                            deck8.map()
                        }
                        hBox5.intercept(0)
                        hBox5.map
                        stochFuncIdxs[specialStochFuncCatIdx] = 15
                        xpanel("")
                        xradiobutton("1, 0, 0, 0, 0, ... (uniform spectrum, useful for colouring filter TF analysis)", "stochFuncChangedHandler(15)", 1)
                        xradiobutton("1, 1, 1, 1, 1, ... (spectral spike at 0, cosine with zero frequency)", "stochFuncChangedHandler(16)", 0)
                        xradiobutton("1, 0, -1, 0, 1, ... (cosine with half-Nyquist frequency)", "stochFuncChangedHandler(17)", 0)
                        xradiobutton("1, -1, 1, -1, 1, ... (cosine with Nyquist frequency)", "stochFuncChangedHandler(18)", 0)
                        xradiobutton("y(m) = foo(2 * PI * m * n / SampleSize), where foo is sin or cos, m = 0, 1, ..., SampleSize - 1", "stochFuncChangedHandler(19)", 0)
                        xpanel()
                    }
                    deck7.intercept(0)
                    // deck7.flip_to(*)     // Will be done in stochFuncCatChangedHandler below
                    deck7.map()
                    xpanel("")
                    xbutton("Select", "selectDistFuncHandler()")
                    xpanel()
                    hBox6 = new HBox()
                    hBox6.intercept(1)
                    {
                        xpanel("")
                        xradiobutton("Show *DF (model)", "shownCurveChangedHandler(0)", shownCurveIdx == 0)
                        xradiobutton("Generate and show a sample (requires \"Dice\")", "shownCurveChangedHandler(1)", shownCurveIdx == 1)
                        xradiobutton("Show *DF from the sample (requires \"Dice\")", "shownCurveChangedHandler(2)", shownCurveIdx == 2)
                        xradiobutton("Show ACF from the sample (requires \"Dice\")", "shownCurveChangedHandler(3)", shownCurveIdx == 3)
                        xradiobutton("Show PSD from the sample (requires \"Dice\")", "shownCurveChangedHandler(4)", shownCurveIdx == 4)
                        xpanel()
                        deck9 = new Deck()
                        deck9.intercept(1)
                        {
                            xpanel("")
                            xradiobutton("Show PDF", "showPdfOrCdfChangedHandler(0)", isShowCdfOrPdf4Model == 0)
                            xradiobutton("Show CDF", "showPdfOrCdfChangedHandler(1)", isShowCdfOrPdf4Model == 1)
                            xpanel()
                            xpanel("")
                            xpvalue("Sample size", &sampleSize, 1)
                            xbutton("Dice", "diceHandler()")
                            xpanel()
                            xpanel("")
                            xradiobutton("Show PDF", "showPdfOrCdfChangedHandler(0)", isShowCdfOrPdf4Sample == 0)  // !!! code dupl. with the code just above
                            xradiobutton("Show CDF", "showPdfOrCdfChangedHandler(1)", isShowCdfOrPdf4Sample == 1)  //
                            xpvalue("Sample size", &sampleSize, 1)                                                 //
                            xpvalue("Number of bins", &numBins, 1)
                            xbutton("Dice", "diceHandler()")                                                       //
                            xpanel()
                        }
                        deck9.intercept(0)
                        // deck9.flip_to(*)     // Will be done in shownCurveChangedHandler below
                        deck9.map()
                    }
                    hBox6.intercept(0)
                    hBox6.map()
                }
                vBox4.intercept(0)
                vBox4.map()
                deck10 = new Deck()
                deck10.intercept(1)
                {
                    graph1 = new Graph()    // PDF (model)
                    graph1.brush(0)         // Without this, graph1 will be dashed if the widget is unmapped and shown again
                    graph1.color(3)         // Blue
                    graph2 = new Graph()    // CDF (model)
                    graph2.brush(0)
                    graph2.color(3)         // Blue
                    graph3 = new Graph()    // A sample
                    graph3.brush(0)
                    graph3.color(2)         // Red
                    graph4 = new Graph()    // PDF (from the sample + model)
                    graph4.brush(1, 1, 0)   // Installing a dash brush; looks like the "pattern" arg doesn't work as described in Neuron docs
                    graph4.brush(0)         // Switching to solid line by default
                    graph5 = new Graph()    // CDF (from the sample + model)
                    graph5.brush(1, 1, 0)
                    graph5.brush(0)
                    graph6 = new Graph()    // ACF (from the sample + model)
                    graph6.brush(1, 1, 0)
                    graph6.brush(0)
                    graph7 = new Graph()    // PSD (from the sample + model)
                    graph7.brush(1, 1, 0)
                    graph7.brush(0)
                    xpanel("")
                    xlabel("*DF curves are not available for Special sequences.")   // Shown for Special instead of graph1, graph2, graph4 and graph5
                    xlabel("Please switch to some other graph.")                    //
                    xpanel()
                }
                deck10.intercept(0)
                // deck10.flip_to(*)     // Will be done in shownCurveChangedHandler below
                deck10.map()
            }
            hBox4.intercept(0)
            hBox4.map()
            xpanel("")
            xbutton("Apply", "applyHandler()")
            xbutton("Disable", "disableHandler()")
            xpanel()
        }
        mainBox.intercept(0)
        mainBox.dismiss_action("dismissHandler()")
        mainBox.map("Stochasticity editor", 460, 50, -1, -1)
        
        boundingWhereChangedHandler(boundingHelper.where)
        boundingModeChangedHandler(boundingHelper.mode)
        noiseChromaticityChangedHandler(colourizationHelper.chromaticity)
        stochFuncCatChangedHandler(stochFuncCatIdx, 1)
    }
    
    proc dismissHandler() {
        dismissChild()
        if (mainBox.ismapped()) {
            mainBox.unmap()
        }
    }
    
    // All next staff is private
    
    
    proc boundingModeChangedHandler() { local boundingMode
        boundingMode = $1
        
        if (boundingMode < 0 || boundingMode > 1) {
            codeContractViolation()
        }
        
        boundingHelper.mode = boundingMode
        
        boundingChangedHandler()
        
        if (boundingHelper.where != 0) {
            updateModelCurves()
        }
    }
    
    proc boundingWhereChangedHandler() { local boundingWhere, cardIdx
        boundingWhere = $1
        
        if (boundingWhere < 0 || boundingWhere > 3) {
            codeContractViolation()
        }
        
        cardIdx = (boundingWhere != 0)
        deck1.flip_to(cardIdx)
        cardIdx = boundingWhere
        deck2.flip_to(cardIdx)
        deck3.flip_to(cardIdx)
        
        boundingHelper.where = boundingWhere
        
        boundingChangedHandler()
        
        updateModelCurves()
    }
    
    proc boundingChangedHandler() { local cardIdx
        if (boundingHelper.where == 0) {
            cardIdx = 0
        } else {
            cardIdx = 1 + boundingHelper.mode
        }
        deck4.flip_to(cardIdx)
    }
    
    proc noiseChromaticityChangedHandler() { local noiseChromaticity
        noiseChromaticity = $1
        deck5.flip_to(noiseChromaticity)
        
        colourizationHelper.chromaticity = noiseChromaticity
        
        if (noiseChromaticity == 0) {
            deck6.flip_to(0)
        } else {
            noiseColourChangedHandler(colourizationHelper.colour)
        }
    }
    
    proc noiseColourChangedHandler() { local noiseColour, cardIdx
        noiseColour = $1
        cardIdx = (noiseColour == 4)
        deck6.flip_to(cardIdx)
        
        colourizationHelper.colour = noiseColour
    }
    
    proc alphaChangedHandler() {
        // !! update model curves on PSD and ACF graphs
    }
    
    proc stochFuncCatChangedHandler() { local numArg, isCalledFromShow, cardIdx
    
        numArg = numarg()
        if (numArg == 1) {
            isCalledFromShow = 0
        } else if (numArg == 2) {
            isCalledFromShow = $2
        } else {
            codeContractViolation()
        }
        
        stochFuncCatIdx = $1
        
        if (stochFuncCatIdx == 0) {
            cardIdx = 0
        } else if (stochFuncCatIdx == specialStochFuncCatIdx) {
            cardIdx = 2
        } else {
            cardIdx = 1
            mwh.showNotImplementedWarning()
        }
        deck7.flip_to(cardIdx)
        
        if (cardIdx == 1) {
            cardIdx = stochFuncCatIdx - 1
            deck8.flip_to(cardIdx)
        }
        
        stochFuncChangedHandler(stochFuncIdxs[stochFuncCatIdx], isCalledFromShow)
    }
    
    proc stochFuncChangedHandler() { local numArg, isCalledFromShow, absValue localobj stochFuncHelper
        
        // !! BUG: We can get here even though the last called "selectedHandler" still didn't exit.
        //         This happens when "selectedHandler" calls "string_dialog", but user
        //         just ignores the string dialog and clicks other radiobutton.
        //         Don't know how to close it like we do with other sub-widgets.
        //         The good news is that it disappears (no idea why) if user continues clicking on radiobuttons
        //         popping up other widgets (that don't call "string_dialog").
        
        numArg = numarg()
        if (numArg == 1) {
            isCalledFromShow = 0
        } else if (numArg == 2) {
            isCalledFromShow = $2
        } else {
            codeContractViolation()
        }
        
        if (!isCalledFromShow) {
            dismissChild()  // This uses stochFuncIdx
        }
        
        stochFuncIdx = $1
        stochFuncIdxs[stochFuncCatIdx] = stochFuncIdx
        
        stochFuncHelper = stochFuncHelpers[stochFuncIdx]
        
        shownCurveChangedHandler(shownCurveIdx)
        
        isCancel = stochFuncHelper.selectedHandler()
        if (isCancel) {
            graph1.erase()
            graph2.erase_all()
            return
        }
        
        updateModelCurves()
    }
    
    proc definePdfOrCdfChangedHandler() {
        mwh.showNotImplementedWarning()
    }
    
    proc shownCurveChangedHandler() { local cardIdx
        shownCurveIdx = $1
        
        if (shownCurveIdx < 0 || shownCurveIdx > 4) {
            codeContractViolation()
        }
        
        if (shownCurveIdx < 3) {
            cardIdx = shownCurveIdx
        } else {
            cardIdx = 1
        }
        deck9.flip_to(cardIdx)
        
        if (shownCurveIdx == 0 || shownCurveIdx == 2) {
            showPdfOrCdfChangedHandler()
        } else {
            if (shownCurveIdx == 1) {
                cardIdx = 2
            } else if (shownCurveIdx == 3 || shownCurveIdx == 4) {
                cardIdx = 2 + shownCurveIdx
            } else {
                codeContractViolation()
            }
            flipDeck10ToCurveOrMessage(shownCurveIdx, cardIdx)
        }
    }
    
    // !!! it would be better to have 2 different implementations depending on the caller
    proc showPdfOrCdfChangedHandler() { local numArg, isShowCdfOrPdf, cardIdx
        numArg = numarg()
        
        if (numArg == 1) {
            isShowCdfOrPdf = $1
        } else if (numArg == 0) {
            if (shownCurveIdx == 0) {
                isShowCdfOrPdf = isShowCdfOrPdf4Model
            } else if (shownCurveIdx == 2) {
                isShowCdfOrPdf = isShowCdfOrPdf4Sample
            } else {
                codeContractViolation()
            }
        } else {
            codeContractViolation()
        }
        
        if (shownCurveIdx == 0) {
            isShowCdfOrPdf4Model = isShowCdfOrPdf
            cardIdx = isShowCdfOrPdf
        } else if (shownCurveIdx == 2) {
            isShowCdfOrPdf4Sample = isShowCdfOrPdf
            cardIdx = 3 + isShowCdfOrPdf
        } else {
            codeContractViolation()
        }
        flipDeck10ToCurveOrMessage(shownCurveIdx, cardIdx)
    }
    
    proc diceHandler() { local isOK
        
        graph3.erase()
        graph4.erase_all()
        graph5.erase_all()
        graph6.erase()
        graph7.erase()
        
        isOK = makeSureCanProceed()
        if (!isOK) {
            return
        }
        
        math.disableGreedyComparison()  // Needed for generateBoundedValue and updateMinMax
        {
            diceHandlerCore()
        }
        math.restoreGreedyComparison()
    }
    
    proc diceHandlerCore() { local yMin, yMax, y, idx, marginFactor, sampleMin, sampleMax, sampleRange, binWidth, xMin4Graph, xMax4Graph, numBins_, histDivider, x, binIdx, yMargin, yMin4Graph, yMax4Graph, mean, newSize localobj stochFuncHelper, sampleVec, histVec, xModelVec, yModelVec, psdVec, acfVec, vfr, vfi
    
        if (stochFuncCatIdx > 0 && stochFuncCatIdx < specialStochFuncCatIdx) {
            // !! not implemented, just to avoid downstream errors (the user has been informed)
            return
        }
        
        colourizationHelper.consumeSettings()
        
        stochFuncHelper = stochFuncHelpers[stochFuncIdx]
        
        // ========== Generating and showing a noise sample
        
        sampleVec = new Vector(sampleSize)
        
        graph3.beginline()
        
        yMin = math.inf
        yMax = -math.inf
        
        y = boundingHelper.generateFirstBoundedValue(stochFuncHelper)
        graph3.line(0, y)
        sampleVec.x[0] = y
        math.updateMinMax(&yMin, &yMax, y)
        
        for idx = 1, sampleSize - 1 {
            y = boundingHelper.generateNextBoundedValue(stochFuncHelper)
            graph3.line(idx, y)
            sampleVec.x[idx] = y
            math.updateMinMax(&yMin, &yMax, y)
        }
        graph3.size(0, sampleSize - 1, yMin, yMax)
        graph3.flush()
        
        // ========== Calculating and showing PDF (from the sample + model)
        
        if (stochFuncCatIdx != specialStochFuncCatIdx) {
            marginFactor = 0.1      // !! hardcode
            
            sampleMin = yMin
            sampleMax = yMax
            
            histVec = new Vector()
            sampleRange = sampleMax - sampleMin
            if (sampleRange > 0) {
                binWidth = sampleRange / numBins
                histVec.hist(sampleVec, sampleMin, numBins, binWidth)
                
                if (histVec.x[0] == 0) {
                    codeContractViolation()
                }
                
                histVec.x[numBins - 1] += sampleSize - histVec.sum()    // This is equivalent to making the last bin "[lo, hi]" instead of "[lo, hi)"
                
                if (histVec.x[numBins - 1] == 0) {
                    codeContractViolation()
                }
                
                numBins_ = numBins
            } else {
                // Just avoiding "Arg out of range in user function" error in histVec.hist
                // (maybe user cut off almost all PDF area)
                
                numBins_ = 1        // !! we don't want to change "numBins" because is't exposed in UI
                binWidth = 1e-8     // !! some hardcode / workaround
                histVec.append(sampleSize)
                sampleMin -= binWidth
                sampleMax += binWidth
                
                // !!! BUG: this bin will not be seen if it's out of the range [xMin4Graph, xMax4Graph] which is chosen for the unbounded model PDF
            }
            
            xModelVec = new Vector()
            yModelVec = new Vector()
            graph1.getline(-1, xModelVec, yModelVec)
            xMin4Graph = xModelVec.x[0]
            xMax4Graph = xModelVec.x[xModelVec.size() - 1]
            
            yMin = 0
            yMax = 0
            
            histDivider = sampleSize * binWidth
            
            // Sample PDF curve
            graph4.color(2)         // Red
            graph4.brush(0)         // Solid
            graph4.beginline()
            x = sampleMin
            y = 0
            graph4.line(xMin4Graph, y)
            graph4.line(x, y)
            for binIdx = 0, numBins_ - 1 {
                histVec.x[binIdx] /= histDivider    // Below we'll use it to calculate CDF
                y = histVec.x[binIdx]
                graph4.line(x, y)
                graph4.line(x + binWidth, y)
                math.updateMinMax(&yMin, &yMax, y)  // !! no need to update yMin actually
                x += binWidth
            }
            y = 0
            graph4.line(sampleMax, y)
            graph4.line(xMax4Graph, y)
            graph4.label("Sample")
            
            // Model PDF curve
            graph4.color(3)         // Blue
            graph4.brush(1)         // Dash
            yModelVec.line(graph4, xModelVec)
            graph4.label("Model")
            
            yMargin = marginFactor * (yMax - yMin)
            yMin4Graph = yMin - yMargin
            yMax4Graph = yMax + yMargin
            
            graph4.size(xMin4Graph, xMax4Graph, yMin4Graph, yMax4Graph)
            graph4.flush()
        }
        
        // ========== Calculating and showing CDF (from the sample + model)
        
        if (stochFuncCatIdx != specialStochFuncCatIdx) {
            // !! major code dupl. with "Calculating and showing PDF (from the sample)"
            
            // Sample CDF curve
            graph5.color(2)         // Red
            graph5.brush(0)         // Solid
            graph5.beginline()
            x = sampleMin
            y = 0
            graph5.line(xMin4Graph, y)
            graph5.line(x, y)
            for binIdx = 0, numBins_ - 1 {
                // Integrating PDF here
                // !! for beter performance, we can calculate CDF first, and then get PDF from it
                //    (actually, CDF must be available somewhere inside histVec.hist called earlier)
                y += histVec.x[binIdx] * binWidth
                graph5.line(x, y)
                graph5.line(x + binWidth, y)
                x += binWidth
            }
            /*
            if (y != 1) {
                // We hit this sometimes due to round-off errors
                // !! to avoid the errors, we can sum up integers and normalize just in the end
                codeContractViolation()
            }
            */
            graph5.line(sampleMax, y)
            graph5.line(xMax4Graph, y)
            graph5.label("Sample")
            
            xModelVec = new Vector()
            yModelVec = new Vector()
            graph2.getline(-1, xModelVec, yModelVec)
            
            // Model CDF curve
            graph5.color(3)         // Blue
            graph5.brush(1)         // Dash
            yModelVec.line(graph5, xModelVec)
            graph5.label("Model")
            
            yMin = 0
            yMax = 1
            yMargin = marginFactor * (yMax - yMin)
            yMin4Graph = yMin - yMargin
            yMax4Graph = yMax + yMargin
            
            graph5.size(xMin4Graph, xMax4Graph, yMin4Graph, yMax4Graph)
            graph5.flush()
        }
        
        // ========== Calculating and showing PSD (from the sample)
        
        if (stochFuncCatIdx != specialStochFuncCatIdx) {
            // !! need to inform user that we remove the mean value from the sample just to get rid of the spike in PSD at 0
            //    (actually, not needed for Uniform and Normal if they are not bounded or bounded symmetrically)
            mean = sampleVec.mean()
            sampleVec.sub(mean)
        }
        
        psdVec = new Vector()
        
        if (!isAltPsdAndAcf) {
            psdVec.spctrm(sampleVec)
            // !! the resulting psdVec is shorter than sampleVec, and maybe that's not what we wanted here
            //    sampleVec.size() / psdVec.size() is 8 if sampleVec.size() is a power of 2
            //    otherwise, the ratio can be < or > than 8
            //    think about Vector.fft or numpy.fft
            
            // !! maybe it makes sense to apply a moving average filter to psdVec before showing it (e.g. using Vector.convlv())
            //    the idea is to let user check if it's constant for white noise and ~ 1 / f ^ alpha for coloured noise
            
            showPsdOrAcfVecOnGraph(psdVec, graph7)
        }
        
        // ========== Calculating and showing ACF (from the sample)
        
        // !! not sure what is computationaly cheaper: to use ifft of PSD or to calculate it directly from the sample
        
        // !! would it make sense to apply a weight window to psdVec before taking ifft (e.g. Hamming)?
        //    for white noise, this would make the delta-spike at 0 more clear
        
        acfVec = new Vector()
        
        if (!isAltPsdAndAcf) {
            // !! do I need to apply pow(2) to psdVec here?
            acfVec.fft(psdVec, -1)
            
            // !! BUG: The result of Vector.fft requires major post-processing before showing on the graph
            //    maybe use "FFT" proc defined here:
            //    https://www.neuron.yale.edu/neuron/static/new_doc/programming/math/vector.html#Vector.fft
        } else {
            
            vfr = new Vector()
            vfi = new Vector()
            FFT(1, sampleVec, vfr, vfi)
            
            psdVec.resize(vfr.size())
            for idx = 0, vfr.size() - 1 {
                psdVec.x(idx) = vfr.x(idx) ^ 2 + vfi.x(idx) ^ 2
                
                vfr.x(idx) = psdVec.x(idx)
                vfi.x(idx) = 0
            }
            
            FFT(-1, acfVec, vfr, vfi)
            
            // !! Neuron docs say: "If vsrc.size() is not an integral power of 2, it is padded with 0’s to the next power of 2 size."
            //    maybe that's not the behaviour we wanted here
        }
        
        /* !! need to inform user that we show the absolute value
        acfVec.abs()
        */
        
        showPsdOrAcfVecOnGraph(acfVec, graph6)
        
        if (isAltPsdAndAcf) {
            // !! applying the logarithmic scale; can we do it with just Graph settings?
            // for idx = 0, vfr.size() - 1 {
            //    psdVec.x(idx) = 10 * log10(psdVec.x(idx))
            // }
            
            // !! don't apply it because we won't see linear func and parabola for alpha = -1 and -2 respectively
            // psdVec.sqrt()
            
            // !! it's not symmetric, so maybe don't move 0 to the center
            // !! for alpha = -2, it makes sense to set ymax just above the median
            showPsdOrAcfVecOnGraph(psdVec, graph7)
        }
        
        // !! BUG: If we select "Special - 1000...", PSD drops to 0 at 0 (independently on isAltPsdAndAcf)
    }
    
    // !! just copied from:
    //    https://www.neuron.yale.edu/neuron/static/new_doc/programming/math/vector.html#Vector.fft
    proc FFT() {local n, x
        if ($1 == 1) { // forward
                $o3.fft($o2, 1)
                n = $o3.size()
                $o3.div(n/2)
                $o3.x[0] /= 2       // makes the spectrum appear discontinuous
                $o3.x[1] /= 2       // but the amplitudes are intuitive

                $o4.copy($o3, 0, 1, -1, 1, 2)   // odd elements
                $o3.copy($o3, 0, 0, -1, 1, 2)   // even elements
                $o3.resize(n/2+1)
                $o4.resize(n/2+1)
                $o3.x[n/2] = $o4.x[0]           //highest cos started in o3.x[1
                $o4.x[0] = $o4.x[n/2] = 0       // weights for sin(0*i)and sin(PI*i)
    }else{ // inverse
                // shuffle o3 and o4 into o2
                n = $o3.size()
                $o2.copy($o3, 0, 0, n-2, 2, 1)
                $o2.x[1] = $o3.x[n-1]
                $o2.copy($o4, 3, 1, n-2, 2, 1)
                $o2.x[0] *= 2
                $o2.x[1] *= 2
                $o2.fft($o2, -1)
        }
    }
    
    proc showPsdOrAcfVecOnGraph() { local n, idx0, idx1, idx2 localobj vec, graph
        vec = $o1
        graph = $o2
        
        graph.color(2)      // Red
        graph.beginline()
        n = vec.size()
        idx0 = n / 2
        for idx1 = 0, n - 1 {
            if (idx1 >= idx0) {
                idx2 = idx1 - idx0
            } else {
                idx2 = idx1 + idx0
            }
            graph.line(idx1 - idx0, vec.x[idx2])
        }
        graph.exec_menu("View = plot")
        graph.flush()
    }
    
    proc updateModelCurves() { localobj stochFuncHelper
    
        if (stochFuncCatIdx > 0 && stochFuncCatIdx < specialStochFuncCatIdx) {
            // !! not implemented, just to avoid downstream errors (the user has been informed)
            return
        }
        
        stochFuncHelper = stochFuncHelpers[stochFuncIdx]
        
        if (stochFuncCatIdx != specialStochFuncCatIdx) {
            math.disableGreedyComparison()  // Needed for calcCdf and makeSureBoundsOK
            {
                isBoundsOK = boundingHelper.prepareForPdfAndCdfBounding(stochFuncHelper.distHelper)
            }
            math.restoreGreedyComparison()
            
            stochFuncHelper.showPdf(graph1)
            stochFuncHelper.showCdf(graph2)
        }
    }
    
    proc selectDistFuncHandler() {
        stochFuncChangedHandler(stochFuncIdx)
    }
    
    proc applyHandler() { local isOK, mechOpIdx, isFound
        strdef verb
        
        isOK = makeSureCanProceed()
        if (!isOK) {
            return
        }
        
        if (!isMechOrSynEditor) {
            mwh.showNotImplementedWarning()
            return
        }
        
        if (isMechOrSynEditor) {
            if (mth.checkIfInhomogeneityOrStochasticityCannotBeAppliedToThisDistMechVar(mechIdx, varType, varName)) {
                return
            }
        }
        
        colourizationHelper.consumeSettings()
        
        // !!
        if (isMechOrSynEditor) {
            mechOpIdx = mmmowb.lastMechOpIdx
            if (mechOpIdx == 1) {
                varsEditorSubWidget.onApplyInStochEditor(varIdx, arrayIndex)
            }
        } else {
            isOK = msmBaseWidget.synManagerMainWidget.warnIfUserHasNotSelectedPPs()
            if (!isOK) {
                return
            }
            msmBaseWidget.synManagerMainWidget.applyChangesToSynStrucIfNeeded()
        }
        
        isFound = inhomAndStochApplicator.enableOrUpdateStochFor(compIdx, mechIdx, varType, varIdx, arrayIndex, boundingHelper, stochFuncHelpers[stochFuncIdx], stochFuncCatIdx, stochFuncIdx)
        if (!isFound) {
            comp.isMechVarTypeStoch[mechIdx][varTypeIdx] = 1    // !!! = (stdDev > 0)
            verb = "enabled"
        } else {
            verb = "updated"
        }
        showStochStatusMsg(1, verb)
    }
    
    proc disableHandler() { local mechOpIdx, isFound
    
        // !!
        if (isMechOrSynEditor) {
            mechOpIdx = mmmowb.lastMechOpIdx
            if (mechOpIdx == 1) {
                varsEditorSubWidget.onDisableInStochEditor(varIdx, arrayIndex)
            } else if (mechOpIdx == 3) {
                // !! need to unmap and show the parent widget again to hide the button
            }
        } else {
            mwh.showNotImplementedWarning()
            return
        }
        
        isFound = inhomAndStochApplicator.disableInhomOrStochFor(0, compIdx, mechIdx, varType, varIdx, arrayIndex)
        if (isFound) {
            comp.isMechVarTypeStoch[mechIdx][varTypeIdx] = 0
            showStochStatusMsg(0, "disabled")
        } else {
            mwh.showMessageBox("Nothing to disable.", "No stochasticity")
        }
    }
    
    proc showStochStatusMsg() { local isEnabled
        strdef verb, line1, title, line2
        isEnabled = $1
        verb = $s2
        sprint(line1, "The stochasticity is %s for \"%s\" in %s.", verb, varNameWithIndex, comp.name)
        sprint(title, "Stochasticity %s", verb)
        if (isEnabled) {
            line2 = "Now you can start the simulation using \"AltRunControl\" widget."
            mwh.showMessageBox(line1, line2, title)
        } else {
            mwh.showMessageBox(line1, title)
        }
    }
    
    proc dismissChild() {
        stochFuncHelpers[stochFuncIdx].dismissHandler()
    }
    
    func makeSureCanProceed() {
        if (!isBoundsOK) {
            boundingHelper.makeSureBoundsOK()   // !! actually, no need to check, just show the last warning once again
            return 0
        }
        if (isCancel) {
            mwh.showWarningBox("Please set the distribution model first.")
            return 0
        }
        return 1
    }
    
    proc flipDeck10ToCurveOrMessage() { local shownCurveIdx, cardIdx
        shownCurveIdx = $1
        cardIdx = $2
        if (stochFuncCatIdx == specialStochFuncCatIdx && (shownCurveIdx == 0 || shownCurveIdx == 2)) {
            cardIdx = 7
        }
        deck10.flip_to(cardIdx)
    }
    
endtemplate StochEditorSubWidget
