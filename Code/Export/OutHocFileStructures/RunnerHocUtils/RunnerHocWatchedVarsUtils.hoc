
numWatchedVars = watchedVarNames.count()
objref recordedVarVecs[numWatchedVars]

objref recordedTimeVec

// in: DtOrMinus1, cvode, recordedVarVecs, recordedTimeVec, numWatchedVars, watchedVarNames (taken from the top level)
proc setUpVarVecsForRecording() { local numRecsOr0, watchedVarIdx
    strdef hocCommandTempl, hocCommand
    
    // Estimate the number of records taking into scope that both "dt" and "tstop" can be swept
    if (DtOrMinus1 != -1) {
        numRecsOr0 = int(tstop / DtOrMinus1 + 1) + 1
    } else if (!cvode.active()) {
        // Letting NEURON change "dt" now rather than on start of the simulation
        setdt()
        numRecsOr0 = int(tstop / dt + 1) + 1
    } else {
        numRecsOr0 = 0      // No estimate
    }
    
    // This works fine for any vars from DMs, PPs/ACs, NetCon-s and top-level vars
    if (DtOrMinus1 != -1) {
        hocCommandTempl = "recordedVarVecs[%d].record(&%s, DtOrMinus1)"
    } else {
        hocCommandTempl = "recordedVarVecs[%d].record(&%s)"
    }
    
    // But according to NEURON docs, in some cases it is preferable to use the following command
    //  hocCommandTempl = "recordedVarVecs[%d].record(pointProcessObject, &%s, [DtOrMinus1])"
    
    if (cvode.active() && DtOrMinus1 == -1) {
        recordedTimeVec = new Vector()
        recordedTimeVec.record(&t)
    }
    
    for watchedVarIdx = 0, numWatchedVars - 1 {
        // This will be resized by NEURON to 0 size just after "run()", here we just allocate memory as they recommend
        recordedVarVecs[watchedVarIdx] = new Vector(numRecsOr0)
        
        sprint(hocCommand, hocCommandTempl, watchedVarIdx, watchedVarNames.o(watchedVarIdx).s)
        execute(hocCommand)
    }
}

// in: outFolderName, timestamp, numSweptVars, numWatchedVars, watchedVarNames, recordedVarVecs, recordedTimeVec, DtOrMinus1 (taken from the top level)
proc saveRecordedVarVecs() { local watchedVarIdx, actNumRecs, recIdx, time localobj outFile
    strdef outFilePathName, line, oneValueStr
    
    sprint(outFilePathName, "%s/vars %s.txt", outFolderName, timestamp)
    outFile = new File()
    outFile.wopen(outFilePathName)
    
    // The swept var names and values
    if (numSweptVars != 0) {
        dumpSweptVarsToFileHeader(outFile)
    }
    
    // The watched var names
    line = "t"
    for watchedVarIdx = 0, numWatchedVars - 1 {
        sprint(line, "%s\t%s", line, watchedVarNames.o(watchedVarIdx).s)
    }
    outFile.printf("%s\n", line)
    
    // The watched var units
    sprint(line, "%s", units(&t))
    for watchedVarIdx = 0, numWatchedVars - 1 {
        sprint(line, "%s\t%s", line, watchedVarUnits.o(watchedVarIdx).s)
    }
    outFile.printf("%s\n", line)
    
    // For fixed time step method, this will be < numRecs if user stopped the cycle
    actNumRecs = recordedVarVecs[0].size()
    
    // The watched var data
    for recIdx = 0, actNumRecs - 1 {
        if (cvode.active() && DtOrMinus1 == -1) {
            time = recordedTimeVec.x(recIdx)
        } else if (DtOrMinus1 != -1) {
            time = recIdx * DtOrMinus1
        } else {
            time = recIdx * dt
        }
        oneValueToString(time, line)
        for watchedVarIdx = 0, numWatchedVars - 1 {
            oneValueToString(recordedVarVecs[watchedVarIdx].x[recIdx], oneValueStr)
            sprint(line, "%s\t%s", line, oneValueStr)
        }
        outFile.printf("%s\n", line)
    }
    
    outFile.close()
}
