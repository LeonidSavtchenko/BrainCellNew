
numWatchedVars = watchedVarNames.count()
objref recordedVecs[numWatchedVars]

// in: numWatchedVars, numRecs, recordedVecs, Dt, watchedVarNames (taken from the top level)
proc setUpVecsForRecording() { local watchedVarIdx
    strdef hocCommandTempl, hocCommand
    
    // This works fine for DMs, PPs and NetCon-s
    hocCommandTempl = "recordedVecs[%d].record(&%s, Dt)"
    
    // But according to NEURON docs, in some cases it is preferable to use the following command
    //  hocCommandTempl = "recordedVecs[%d].record(pointProcessObject, &%s, Dt)"
    
    for watchedVarIdx = 0, numWatchedVars - 1 {
        // This will be resized by NEURON to 0 size just after "run()", here we just allocate memory as they recommend
        recordedVecs[watchedVarIdx] = new Vector(numRecs)
        
        sprint(hocCommand, hocCommandTempl, watchedVarIdx, watchedVarNames.o(watchedVarIdx).s)
        execute(hocCommand)
    }
}

objref pyObj

// in: outFileNameFormat, outFolderName, numSweptVars, numWatchedVars, watchedVarNames, recordedVecs, Dt, oneValueFormat (taken from the top level)
proc saveRecordedVecs() { local watchedVarIdx, actNumRecs, recIdx, time localobj outFile
    strdef pyCommand, outFileName, outFilePathName, line, oneValueStr
    
    sprint(pyCommand, "(exec('import datetime'), datetime.datetime.now().strftime('%s'))[1]", outFileNameFormat)
    outFileName = pyObj.ev(pyCommand)
    
    sprint(outFilePathName, "%s/%s", outFolderName, outFileName)
    outFile = new File()
    outFile.wopen(outFilePathName)
    
    // The swept var names and values
    if (numSweptVars != 0) {
        dumpSweptVarsToFileHeader(outFile)
    }
    
    // The watched var names
    line = "t"
    for watchedVarIdx = 0, numWatchedVars - 1 {
        sprint(line, "%s\t%s", line, watchedVarNames.o(watchedVarIdx).s)
    }
    outFile.printf("%s\n", line)
    
    // The watched var units
    sprint(line, "%s", units(&t))
    for watchedVarIdx = 0, numWatchedVars - 1 {
        sprint(line, "%s\t%s", line, watchedVarUnits.o(watchedVarIdx).s)
    }
    outFile.printf("%s\n", line)
    
    // This will be < numRecs if user stopped the cycle
    actNumRecs = recordedVecs[0].size()
    
    // The watched var data
    for recIdx = 0, actNumRecs - 1 {
        time = recIdx * Dt
        sprint(line, oneValueFormat, time)
        for watchedVarIdx = 0, numWatchedVars - 1 {
            sprint(oneValueStr, oneValueFormat, recordedVecs[watchedVarIdx].x[recIdx])
            sprint(line, "%s\t%s", line, oneValueStr)
        }
        outFile.printf("%s\n", line)
    }
    
    outFile.close()
}
