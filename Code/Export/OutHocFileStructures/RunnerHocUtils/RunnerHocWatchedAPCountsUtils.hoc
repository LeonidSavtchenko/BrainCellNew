
// Just some declarations for binding in the proc-s below (will be defined before the first usage)
numWatchedAPCounts = -1
objref apcList, recordedVecsFromAPCounts[1]

// in: numWatchedAPCounts, apcList, recordedVecsFromAPCounts (taken from the top level)
proc setUpVecsForRecordingFromAPCounts() { local apcIdx localobj vec
    for apcIdx = 0, numWatchedAPCounts - 1 {
        vec = new Vector()
        apcList.o(apcIdx).record(vec)
        recordedVecsFromAPCounts[apcIdx] = vec
    }
}

// in: outFolderName, timestamp, numSweptVars, numWatchedAPCounts, apcList, recordedVecsFromAPCounts, oneValueFormat (taken from the top level)
proc saveRecordedVecsFromAPCounts() { local apcIdx, maxNumRecs, n, recIdx localobj outFile, vec
    strdef outFilePathName, line, unitsStr, tempStr
    
    sprint(outFilePathName, "%s/aps %s.txt", outFolderName, timestamp)
    outFile = new File()
    outFile.wopen(outFilePathName)
    
    // The swept var names and values
    if (numSweptVars != 0) {
        dumpSweptVarsToFileHeader(outFile)
    }
    
    // The time var name
    line = "t"
    for apcIdx = 1, numWatchedAPCounts - 1 {
        sprint(line, "%s\tt", line)
    }
    outFile.printf("%s\n", line)
    
    // The time var units
    unitsStr = units(&t)
    sprint(line, "%s", unitsStr)
    for apcIdx = 1, numWatchedAPCounts - 1 {
        sprint(line, "%s\t%s", line, unitsStr)
    }
    outFile.printf("%s\n", line)
    
    // The locations of APCount-s
    getAPCountLocationHint(0, line)
    for apcIdx = 1, numWatchedAPCounts - 1 {
        getAPCountLocationHint(apcIdx, tempStr)
        sprint(line, "%s\t%s", line, tempStr)
    }
    outFile.printf("%s\n", line)
    
    // The thresholds of APCount-s
    getAPCountThresholdHint(0, line)
    for apcIdx = 1, numWatchedAPCounts - 1 {
        getAPCountThresholdHint(apcIdx, tempStr)
        sprint(line, "%s\t%s", line, tempStr)
    }
    outFile.printf("%s\n", line)
    
    maxNumRecs = -1
    for apcIdx = 0, numWatchedAPCounts - 1 {
        n = apcList.o(apcIdx).n
        if (n > maxNumRecs) {
            maxNumRecs = n
        }
    }
    
    // The recorded times of action potentials
    for recIdx = 0, maxNumRecs - 1 {
        
        // The first column
        vec = recordedVecsFromAPCounts[0]
        if (recIdx < vec.size()) {
            sprint(line, oneValueFormat, vec.x(recIdx))
        } else {
            line = ""
        }
        
        // All next columns
        for apcIdx = 1, numWatchedAPCounts - 1 {
            vec = recordedVecsFromAPCounts[apcIdx]
            if (recIdx < vec.size()) {
                sprint(tempStr, oneValueFormat, vec.x(recIdx))
                sprint(line, "%s\t%s", line, tempStr)
            } else {
                sprint(line, "%s\t", line)
            }
        }
        
        outFile.printf("%s\n", line)
    }
    
    outFile.close()
}

// in: apcList, pyObj (taken from the top level)
proc getAPCountLocationHint() { local apcIdx, x
    apcIdx = $1
    x = apcList.o(apcIdx).get_loc()
    {
        sprint($s2, "loc = %s( %s )", secname(), pyObj.str(x))
    }
    pop_section()
}

// in: apcList, pyObj (taken from the top level)
proc getAPCountThresholdHint() { local apcIdx
    apcIdx = $1
    sprint($s2, "thresh = %s (mV)", pyObj.str(apcList.o(apcIdx).thresh))    // !!!! hardcode
}
