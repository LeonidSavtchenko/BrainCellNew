
begintemplate ReducedSynGroup

    public createSynStruc, initAllHomogenVars, applyInhomogeneityIter
    
    external smAllSyns, smAllComps
    external seh, rngUtils
    external eachItemInList
    external enumSynCompIdxs
    
    objref this
    
    
    // Keep in sync with SynGroup.applyChangesToStrucIfNeeded
    proc createSynStruc() { local is3Or1PartInSynStruc, srcMechIdx, isSefwEnabled, seed localobj syn, srcPp, trgPp, netCon, sefwPp, sefwNetCon, sngPp
        strdef srcMechName, trgMechName, sngMechName
        
        is3Or1PartInSynStruc = $1
        srcMechIdx = $2
        srcMechName = $s3
        trgMechName = $s4
        sngMechName = $s5
        
        if (is3Or1PartInSynStruc) {
            isSefwEnabled = seh.isSefwEnabled()
            
            for eachItemInList(syn, smAllSyns) {
                srcPp = createNewSrcPp(syn, srcMechIdx, srcMechName)
                trgPp = createNewPpAttachedToSection(trgMechName, syn.sec_ref, syn.connectionPoint)
                if (!isSefwEnabled) {
                    netCon = new NetCon(srcPp, trgPp)
                    syn.changeStructure(srcPp, netCon, trgPp)
                } else {
                    seh.createNewSynEventsFilterWatcherButTryToInherit(syn, 0, 0, trgPp, sefwPp, sefwNetCon)
                    netCon = new NetCon(srcPp, sefwPp)
                    syn.changeStructure(srcPp, netCon, sefwPp, sefwNetCon, trgPp)
                }
            }
            if (isSefwEnabled) {
                // It's enough to set the seed only once per rank (for the last sefwPp in our case)
                seed = rngUtils.getSeedFor_SEFW()
                sefwPp.setSeed(seed)
            }
        } else {
            for eachItemInList(syn, smAllSyns) {
                sngPp = createNewPpAttachedToSection(sngMechName, syn.sec_ref, syn.connectionPoint)
                syn.changeStructure(sngPp)
            }
        }
    }
    
    // Keep in sync with SynGroup.applyChangesToDirtyHomogenVars
    proc initAllHomogenVars() { local is3Or1PartInSynStruc, srcMechIdx, trgMechIdx, sngMechIdx
        is3Or1PartInSynStruc = $1
        srcMechIdx = $2
        trgMechIdx = $3
        sngMechIdx = $4
        if (is3Or1PartInSynStruc) {
            initHomogenVars(enumSynCompIdxs.srcPp, srcMechIdx, 0)
            initHomogenVars(enumSynCompIdxs.netCon, 0, -1)
            initHomogenVars(enumSynCompIdxs.trgPp, trgMechIdx, 1)
        } else {
            initHomogenVars(enumSynCompIdxs.sngPp, sngMechIdx, 2)
        }
    }
    
    // Keep in sync with SynGroup.applyInhomogeneityIter
    iterator applyInhomogeneityIter() { local synIdx localobj distFuncHelper, nil, prevSec_ref, syn
        distFuncHelper = $o2
        
        distFuncHelper.onJustBeforeFirstSection()
        {
            prevSec_ref = nil
            for synIdx = 0, smAllSyns.count() - 1 {
                syn = smAllSyns.o(synIdx)
                if (syn.sec_ref != prevSec_ref) {
                    distFuncHelper.onJustBeforeNewSection()
                }
                $o1 = syn
                iterator_statement
                prevSec_ref = syn.sec_ref
            }
        }
        distFuncHelper.onJustAfterLastSection()
    }
    
    // All next staff is private
    
    
    // Keep in sync with SynGroup.createNewSrcPpButTryToInherit
    obfunc createNewSrcPp() { local mechIdx, doesSrcPpRequireSection localobj syn, mechType, pp
        strdef mechName
        
        syn = $o1
        mechIdx = $2
        mechName = $s3
        
        mechType = new MechanismType(1)     // 1: "Point Processes"
        
        doesSrcPpRequireSection = !mechType.is_artificial(mechIdx)
        
        if (!doesSrcPpRequireSection) {
            mechType.select(mechName)
            mechType.make(pp)   // Not located in any section
            return pp
        } else {
            return createNewPpAttachedToSection(mechName, syn.sec_ref, syn.connectionPoint)
        }
    }
    
    objref _tempPp
    
    // Keep in sync with SynGroup.createNewPpAttachedToSectionButTryToInherit
    obfunc createNewPpAttachedToSection() { local x localobj sec_ref, pp, nil
        strdef mechName, hocCommand
        
        mechName = $s1
        sec_ref = $o2
        x = $3
        
        sprint(hocCommand, "_tempPp = new %s(%.15e)", mechName, x)
        sec_ref.sec {
            execute(hocCommand, this)
        }
        
        pp = _tempPp
        _tempPp = nil
        
        return pp
    }
    
    // Keep in sync with SynGroup.ifMechDirtyThenApplyHomogenChanges
    proc initHomogenVars() { local compIdx, mechIdx, enumPpRole, isPPorNC, maxVarType, varType, varTypeIdx localobj comp, syn, nil, sefwPpOrNil, sefwNetConOrNil, ppOrNetCon, compMechStd
        
        compIdx = $1
        mechIdx = $2
        enumPpRole = $3
        
        comp = smAllComps.o(compIdx)
        
        isPPorNC = (compIdx != enumSynCompIdxs.netCon)
        
        for eachItemInList(syn, smAllSyns) {
            sefwPpOrNil = nil
            sefwNetConOrNil = nil
            if (isPPorNC) {
                ppOrNetCon = syn.getPointProcess(enumPpRole)
                maxVarType = 3
            } else {
                ppOrNetCon = syn.netCon
                if (seh.isSefwEnabled()) {
                    sefwPpOrNil = syn.sefwPp
                    sefwNetConOrNil = syn.sefwNetCon
                }
                maxVarType = 1
            }
            for varType = 1, maxVarType {   // 1: "PARAMETER", 2: "ASSIGNED", 3: "STATE"
                varTypeIdx = varType - 1
                compMechStd = comp.mechStds[mechIdx][varTypeIdx]
                if (compMechStd == nil) {
                    continue
                }
                // Here we assign NaN values to inhom vars, but they will be overwritten shortly downstream
                compMechStd.out(ppOrNetCon)
            }
            if (sefwPpOrNil != nil) {
                if (compMechStd != nil) {
                    // The same comment regarding NaN values
                    sefwPpOrNil.release_probability = compMechStd.get(seh.metaVarName)
                } else {
                    // We get here when all NetCon params are default (so its mechStd is nil), but stochasticity is enabled
                    sefwPpOrNil.release_probability = 1
                }
            }
            if (sefwNetConOrNil != nil) {
                if (compMechStd != nil) {
                    // The same comment regarding NaN values
                    compMechStd.out(sefwNetConOrNil)
                }
                sefwNetConOrNil.delay = 0
            }
        }
    }
    
endtemplate ReducedSynGroup

objref synGroup
synGroup = new ReducedSynGroup()
