
// Keep in sync with RNGUtils
begintemplate ReducedRNGUtils

    public getFor_stochFunc_withUniqueSeed, getSeedFor_SEFW
    
    uniqueSeedForHoc = -1
    uniqueSeedForMod = -1
    
    
    proc init() { local minSeedForMod, maxNumSeedsPerRankForMod localobj pc
        uniqueSeedForHoc = 9
        
        if (!use_mcell_ran4()) {
            minSeedForMod = 0       // HOC and MOD use different RNGs, so we don't care about seeds overlapping
        } else {
            minSeedForMod = 10000   // HOC and MOD can use the same RNG, so we try to prevent seeds overlapping
        }
        
        // How many times user can change synapse structure per 1 session with the guarantee of unique seeds
        maxNumSeedsPerRankForMod = 1000
        
        pc = new ParallelContext()
        uniqueSeedForMod = minSeedForMod + maxNumSeedsPerRankForMod * pc.id
    }
    
    obfunc getFor_stochFunc_withUniqueSeed() { localobj rng
        rng = new Random(uniqueSeedForHoc)
        uniqueSeedForHoc += 1
        return rng
    }
    
    func getSeedFor_SEFW() { local seed
        seed = uniqueSeedForMod
        uniqueSeedForMod += 1
        return seed
    }
    
endtemplate ReducedRNGUtils
