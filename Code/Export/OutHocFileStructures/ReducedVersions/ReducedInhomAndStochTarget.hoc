
begintemplate ReducedInhomAndStochTarget

    public makeInhom, makeStoch, isEqual, applyBiophysInhomogeneity, setPlayIfPossible, stopPlayingVars, onInit, onStep
    public enumDmPpNc, compIdx, mechIdx, varType, varIdx, arrayIndex
    public segmentationHelper, distFuncHelper, boundingHelper, stochFuncHelper
    public isInhom, distFuncCatIdx, distFuncIdx, isStoch, stochFuncCatIdx, stochFuncIdx
    
    external mmAllComps
    external rngUtils
    external codeContractViolation
    external eachItemInList
    
    // "init" args
    enumDmPpNc = -1
    isDmOrSynPart = -1
    compIdx = -1
    mechIdx = -1
    varType = -1
    varIdx = -1
    strdef varName
    arrayIndex = -1
    
    // "make*" args
    objref segmentationHelper, distFuncHelper
    objref boundingHelper, stochFuncHelper
    isInhom = -1
    distFuncCatIdx = -1
    distFuncIdx = -1
    isStoch = -1
    stochFuncCatIdx = -1
    stochFuncIdx = -1
    
    objref list_ref
    
    objref baseMechStd, tempMechStd
    
    objref this
    
    
    proc init() { local varTypeIdx localobj comp, mechType
        strdef mechName
        
        enumDmPpNc = $1
        compIdx = $2
        mechIdx = $3
        varType = $4
        varIdx = $5
        arrayIndex = $6
        
        isDmOrSynPart = (enumDmPpNc == 0)
        
        if (!isDmOrSynPart) {
            codeContractViolation()
        }
        
        comp = mmAllComps.o(compIdx)
        
        list_ref = comp.list_ref
        
        varTypeIdx = varType - 1
        baseMechStd = comp.mechStds[mechIdx][varTypeIdx]
        
        mechType = new MechanismType(0)     // 0: "Distributed Membrane Mechanisms"
        mechType.select(mechIdx)
        mechType.selected(mechName)
        
        tempMechStd = new MechanismStandard(mechName, varType)
        tempMechStd.name(varName, varIdx)
    }
    
    proc makeInhom() {
        segmentationHelper = $o1
        distFuncHelper = $o2
        distFuncCatIdx = $3
        distFuncIdx = $4
        isInhom = 1
        setIsPlayable()
    }
    
    proc makeStoch() {
        boundingHelper = $o1
        stochFuncHelper = $o2
        stochFuncCatIdx = $3
        stochFuncIdx = $4
        isStoch = 1
        setIsPlayable()
    }
    
    func isEqual() {
        return (enumDmPpNc == $1 && compIdx == $2 && mechIdx == $3 && varType == $4 && varIdx == $5 && arrayIndex == $6)
    }
    
    // Keep in sync with MechComp.applySegmentationAndInhomogeneity
    proc applyBiophysInhomogeneity() { local secIdx, x, dist, y
    
        if (!isDmOrSynPart || !isInhom || varType == -1) {  // -1: "GLOBAL"
            codeContractViolation()
        }
        
        distFuncHelper.onJustBeforeFirstSection()
        for secIdx = 0, list_ref.count() - 1 {
            list_ref.o(secIdx).sec {
                distFuncHelper.onJustBeforeNewSection()
                for (x, 0) {
                    tempMechStd.in(x)
                    dist = distance(x)
                    y = distFuncHelper.calculateAt(dist)
                    tempMechStd.set(varName, y, arrayIndex)
                    tempMechStd.out(x)
                }
            }
        }
        distFuncHelper.onJustAfterLastSection()
    }
    
    // Keep in sync with InhomAndStochTarget.setPlayIfPossible
    func setPlayIfPossible() { local x, homogenValue localobj sec_ref
        strdef hocCommand
        
        if (!isPlayable) {
            return 0
        }
        
        for eachItemInList(sec_ref, list_ref) {
            sec_ref.sec for (x, 0) {
                sprint(hocCommand, "stochFuncHelper.rng.play(&%s(%.15e))", varName, x)
                execute(hocCommand, this)
            }
        }
        
        homogenValue = baseMechStd.get(varName, arrayIndex)
        distFuncHelper.setMeanOnStartPlaying(homogenValue)
        
        return 1
    }
    
    // Keep in sync with InhomAndStochTarget.stopPlayingVars
    proc stopPlayingVars() {
        if (!isPlayable) {
            return
        }
        
        // NEURON docs say: "To disconnect the Random object from its list of variables, either the variables or the Random object must be destroyed."
        // But actually it doesn't seem like there's any way to destroy the "played" Random object without dire consequences.
        
        // !! BUG: Hanging here, and the same effect if we just assign "nil" to stochFuncHelper.rng
        //         No hanging if we don't call stochFuncHelper.rng.play upstream
        //         It looks like we have only two options to disable the "play" effect:
        //         1. "create" all sections in list_ref from scratch (replacing the old sections) - and only after this we can destroy the old RNG
        //         2. Adjust RNG to produce constant and copy the generator to some storage just to keep alive while we replace stochFuncHelper.rng
        //            (If we play the same var with multiple RNG-s, only the last one has visible effect)
        //            But after this, we won't be able to make the var inhomogeneous
        //         Alternatively, we could use Vector.play() and Vector.play_remove() instead of Random.play(),
        //         but this requires some troublesome orchestration and looks like not giving an advantage compared to the non-played mode in our case
        stochFuncHelper.rng = rngUtils.getFor_stochFunc_withUniqueSeed()
        
        distFuncHelper.resetMeanOnStopPlaying()
    }
    
    // Keep in sync with InhomAndStochTarget.onInit
    proc onInit() {
        if (isStoch) {
            // One unused value to set up the generator and the colourizer
            boundingHelper.generateFirstBoundedValue(stochFuncHelper)
        }
    }
    
    // Keep in sync with InhomAndStochTarget.onStep
    proc onStep() { local homogenValue, x, value, dist localobj sec_ref
        if (isPlayable) {
            return
        }
        if (varType == 1 && !isStoch) { // 1: "PARAMETER"
            if (isInhom) {
                return
            } else {
                codeContractViolation()
            }
        }
        
        if (!isDmOrSynPart) {
            codeContractViolation()
        }
        
        if (isInhom) {
            distFuncHelper.onJustBeforeFirstSection()
        } else {
            homogenValue = baseMechStd.get(varName, arrayIndex)
        }
        
        for eachItemInList(sec_ref, list_ref) {
            sec_ref.sec {
                if (isInhom) {
                    distFuncHelper.onJustBeforeNewSection()
                }
                for (x, 0) {
                    // The base value
                    if (isInhom) {
                        dist = distance(x)
                        value = distFuncHelper.calculateAt(dist)
                    } else {
                        value = homogenValue
                    }
                    
                    // The additive noise
                    if (isStoch) {
                        value += boundingHelper.generateNextBoundedValue(stochFuncHelper)
                    }
                    
                    // This approach is 20-30% faster than "sprint"-ing a HOC-command
                    // of type "varName(x) = value" or "varName[arrayIndex](x) = value" and then "execute"-ing it
                    tempMechStd.in(x)
                    tempMechStd.set(varName, value, arrayIndex)
                    tempMechStd.out(x)
                }
            }
        }
        
        if (isInhom) {
            distFuncHelper.onJustAfterLastSection()
        }
    }
    
    // All next staff is private
    
    
    // Keep in sync with InhomAndStochTarget.setIsPlayable
    proc setIsPlayable() {
        if (!isStoch) {
            isPlayable = 0
            return          // Just a shortcut because boundingHelper used below is nil
        }
        isPlayable = (!isInhom && stochFuncCatIdx == 0 && (stochFuncIdx == 0 || stochFuncIdx == 1) && boundingHelper.isUntouched())
        
        // !! not implemented - see the comment in stopPlayingVars
        isPlayable = 0
    }
    
endtemplate ReducedInhomAndStochTarget
