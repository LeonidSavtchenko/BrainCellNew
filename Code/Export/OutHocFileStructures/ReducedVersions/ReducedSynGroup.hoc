
begintemplate ReducedSynGroup

    public applyChangesToStrucIfNeeded, applyChangesToAllHomogenVars
    
    external smAllSyns, smAllComps
    external mcu, seh, rngUtils
    external stringsEqual, codeContractViolation
    external eachItemInList
    external enumSynCompIdxs
    
    objref mechType
    
    objref this
    
    
    proc init() {
        mechType = new MechanismType(1)     // 1: "Point Processes"
    }
    
    // Keep in sync with SynGroup.applyChangesToStrucIfNeeded
    func applyChangesToStrucIfNeeded() { local is3Or1PartInSynStruc_new, srcMechIdx, trgMechIdx, sngMechIdx, isForceNewTrgOrSng, is3Or1PartInSynStruc_old, enumTrgOrSngPpRole_old, isSefwEnabled, isSrcMechNameUnchanged, isSefwPresenceUnchanged, isTrgMechNameUnchanged, seed localobj syn, srcPp, trgPp, netCon, sefwPp, sefwNetCon, oldPp, sngPp
        strdef srcMechName, trgMechName, sngMechName, trgOrSngMechName_old, srcMechName_old, trgMechName_old, sngMechName_old
        
        is3Or1PartInSynStruc_new = $1
        srcMechIdx = $2
        trgMechIdx = $3
        sngMechIdx = $4
        srcMechName = $s5
        trgMechName = $s6
        sngMechName = $s7
        isForceNewTrgOrSng = $8
        
        is3Or1PartInSynStruc_old = is3Or1PartInSynStruc()
        
        if (is3Or1PartInSynStruc_old) {
            enumTrgOrSngPpRole_old = 1
        } else {
            enumTrgOrSngPpRole_old = 2
        }
        getPpNameOrEmpty(0, srcMechName_old)
        getPpNameOrEmpty(1, trgMechName_old)
        getPpNameOrEmpty(2, sngMechName_old)
        getPpNameOrEmpty(enumTrgOrSngPpRole_old, trgOrSngMechName_old)
        
        if (is3Or1PartInSynStruc_new) {
            isSefwEnabled = seh.isSefwEnabled()
            isSrcMechNameUnchanged = stringsEqual(srcMechName, srcMechName_old)
            isSefwPresenceUnchanged = (isSefwEnabled == isSefwPresentInSynStruc())
            isTrgMechNameUnchanged = stringsEqual(trgMechName, trgMechName_old)
            if (!isForceNewTrgOrSng && isSrcMechNameUnchanged && isSefwPresenceUnchanged && isTrgMechNameUnchanged) {
                return 0
            }
            
            for eachItemInList(syn, smAllSyns) {
                srcPp = createNewSrcPpButTryToInherit(syn, srcMechIdx, srcMechName, isSrcMechNameUnchanged)
                trgPp = createNewTrgOrSngPpButTryToInherit(syn, trgMechIdx, trgMechName, isForceNewTrgOrSng, enumSynCompIdxs.trgPp, enumTrgOrSngPpRole_old, trgOrSngMechName_old)
                if (!isSefwEnabled) {
                    netCon = createNewNetConButTryToInherit(syn, srcPp, trgPp, is3Or1PartInSynStruc_old)
                    syn.changeStructure(srcPp, netCon, trgPp)
                } else {
                    seh.createNewSynEventsFilterWatcherButTryToInherit(syn, isSefwPresenceUnchanged, is3Or1PartInSynStruc_old, trgPp, sefwPp, sefwNetCon)
                    netCon = createNewNetConButTryToInherit(syn, srcPp, sefwPp, is3Or1PartInSynStruc_old)
                    syn.changeStructure(srcPp, netCon, sefwPp, sefwNetCon, trgPp)
                }
            }
            if (isSefwEnabled) {
                // It's enough to set the seed only once per rank (for the last sefwPp in our case)
                seed = rngUtils.getSeedFor_SEFW()
                sefwPp.setSeed(seed)
            }
        } else {
            if (!isForceNewTrgOrSng && stringsEqual(sngMechName, sngMechName_old)) {
                return 0
            }
            for eachItemInList(syn, smAllSyns) {
                sngPp = createNewTrgOrSngPpButTryToInherit(syn, sngMechIdx, sngMechName, isForceNewTrgOrSng, enumSynCompIdxs.sngPp, enumTrgOrSngPpRole_old, trgOrSngMechName_old)
                syn.changeStructure(sngPp)
            }
        }
        
        return 1
    }
    
    // Keep in sync with SynGroup.applyChangesToDirtyHomogenVars
    proc applyChangesToAllHomogenVars() { local srcMechIdx, trgMechIdx, sngMechIdx
        srcMechIdx = $1
        trgMechIdx = $2
        sngMechIdx = $3
        if (is3Or1PartInSynStruc()) {
            applyHomogenChanges(enumSynCompIdxs.srcPp, srcMechIdx, 0)
            applyHomogenChanges(enumSynCompIdxs.netCon, 0, -1)
            applyHomogenChanges(enumSynCompIdxs.trgPp, trgMechIdx, 1)
        } else {
            applyHomogenChanges(enumSynCompIdxs.sngPp, sngMechIdx, 2)
        }
    }
    
    // All next staff is private
    
    
    // Keep in sync with SynGroup.getPpNameOrEmpty
    proc getPpNameOrEmpty() { local enumPpRole, idx localobj pp, nil, strFunc
        strdef ppNameWithBrackets, ppName
        
        enumPpRole = $1     // 0: "Source PP", 1: "Target PP", 2: "Single PP"
        
        // It's a code contract that all the syns have the same structure
        pp = smAllSyns.o(0).getPointProcess(enumPpRole)
        if (pp == nil) {
            $s2 = ""
            return
        }
        
        // !! maybe this can be optimized significantly (e.g. with Python) or at least we can extract and call a shared util
        sprint(ppNameWithBrackets, "%s", pp)
        strFunc = new StringFunctions()
        idx = strFunc.head(ppNameWithBrackets, "\\[", ppName)
        if (idx == -1) {
            codeContractViolation()
        }
        
        $s2 = ppName
    }
    
    // Keep in sync with SynGroup.createNewSrcPpButTryToInherit
    obfunc createNewSrcPpButTryToInherit() { local mechIdx, isSrcMechNameUnchanged, doesSrcPpRequireSection, synCompIdx localobj syn, outPp
        strdef mechName
        
        syn = $o1
        mechIdx = $2
        mechName = $s3
        isSrcMechNameUnchanged = $4
        
        if (isSrcMechNameUnchanged) {
            return syn.srcPp
        }
        
        doesSrcPpRequireSection = !mechType.is_artificial(mechIdx)
        synCompIdx = enumSynCompIdxs.srcPp
        
        if (!doesSrcPpRequireSection) {
            mechType.select(mechName)
            mechType.make(outPp)    // Not located in any section
            setDefaultVars(synCompIdx, mechIdx, outPp)
            return outPp
        } else {
            return createNewPpAttachedToSectionButTryToInherit(syn.srcPp, synCompIdx, mechIdx, mechName, syn.sec_ref, syn.connectionPoint, 0)
        }
    }
    
    // Keep in sync with SynGroup.createNewTrgOrSngPpButTryToInherit
    obfunc createNewTrgOrSngPpButTryToInherit() { local mechIdx, isForceNew, synCompIdx, enumPpRole_old, isMechNameUnchanged localobj syn, pp_old
        strdef mechName, mechName_old
        
        syn = $o1
        mechIdx = $2
        mechName = $s3
        isForceNew = $4
        synCompIdx = $5
        enumPpRole_old = $6
        mechName_old = $s7
        
        pp_old = syn.getPointProcess(enumPpRole_old)
        isMechNameUnchanged = stringsEqual(mechName, mechName_old)
        if (!isForceNew && isMechNameUnchanged) {
            return pp_old
        } else {
            return createNewPpAttachedToSectionButTryToInherit(pp_old, synCompIdx, mechIdx, mechName, syn.sec_ref, syn.connectionPoint, isMechNameUnchanged)
        }
    }
    
    objref _tempFms4nc
    
    // Keep in sync with SynGroup.createNewNetConButTryToInherit
    obfunc createNewNetConButTryToInherit() { local is3Or1PartInSynStruc_old localobj syn, srcPp, nextPp, netCon, nil
        syn = $o1
        srcPp = $o2
        nextPp = $o3
        is3Or1PartInSynStruc_old = $4
        
        netCon = new NetCon(srcPp, nextPp)
        if (is3Or1PartInSynStruc_old) {
            execute("_tempFms4nc = new FakeMechanismStandardForNetCon()", this)     // The template is not exported if !is3Or1PartInSynStruc_old
            _tempFms4nc.in(syn.netCon)
            _tempFms4nc.out(netCon)
            _tempFms4nc = nil
        } else {
            setDefaultVars(enumSynCompIdxs.netCon, 0, netCon)
        }
        
        return netCon
    }
    
    objref _tempPp
    
    // Keep in sync with SynGroup.createNewPpAttachedToSectionButTryToInherit
    obfunc createNewPpAttachedToSectionButTryToInherit() { local synCompIdx, mechIdx, x, isMechNameUnchanged localobj pp_old, sec_ref, pp_new, nil, mechStd
        strdef mechName, hocCommand
        
        pp_old = $o1
        synCompIdx = $2
        mechIdx = $3
        mechName = $s4
        sec_ref = $o5
        x = $6
        isMechNameUnchanged = $7
        
        sprint(hocCommand, "_tempPp = new %s(%.15e)", mechName, x)
        sec_ref.sec {
            execute(hocCommand, this)
        }
        
        pp_new = _tempPp
        _tempPp = nil
        
        if (isMechNameUnchanged) {
            mechStd = new MechanismStandard(mechName)
            mechStd.in(pp_old)
            mechStd.out(pp_new)
        } else {
            setDefaultVars(synCompIdx, mechIdx, pp_new)
        }
        
        return pp_new
    }
    
    // Keep in sync with SynGroup.setDefaultVars
    proc setDefaultVars() { local synCompIdx, mechIdx, numVarTypes, varTypeIdx localobj pp, comp, mechStd, nil
        synCompIdx = $1
        mechIdx = $2
        pp = $o3
        
        comp = smAllComps.o(synCompIdx)
        
        if (comp.enumDmPpNc == 1) {
            numVarTypes = 3     // "PARAMETER", "ASSIGNED", "STATE"
        } else if (comp.enumDmPpNc == 2) {
            numVarTypes = 1
        } else {
            codeContractViolation()
        }
        
        for varTypeIdx = 0, numVarTypes - 1 {   // 0: "PARAMETER", 1: "ASSIGNED", 2: "STATE"
            mechStd = comp.mechStds[mechIdx][varTypeIdx]
            if (mechStd == nil) {
                continue
            }
            // This inserts NaN-s for inhomogen vars,
            // but we'll restore all inhomogeneities shortly downstream calling inhomAndStochLibrary.onSynStrucChange
            mechStd.out(pp)
        }
    }
    
    // Keep in sync with SynGroup.is3Or1PartInSynStruc
    func is3Or1PartInSynStruc() { localobj nil
        // It's a code contract that all the syns have the same structure
        return (smAllSyns.o(0).netCon != nil)
    }
    
    // Keep in sync with SynGroup.isSefwPresentInSynStruc
    func isSefwPresentInSynStruc() { localobj nil
        // It's a code contract that all the syns have the same structure
        return (smAllSyns.o(0).sefwPp != nil)
    }
    
    objref _tempMechStdExt
    
    // Keep in sync with SynGroup.ifMechDirtyThenApplyHomogenChanges
    proc applyHomogenChanges() { local compIdx, mechIdx, enumPpRole, isPPorNC, maxVarType, varType, varTypeIdx localobj comp, syn, ppOrNetCon, sefwNetConOrNil, nil, compMechStd
        strdef mechName, varName
        
        compIdx = $1
        mechIdx = $2
        enumPpRole = $3
        
        comp = smAllComps.o(compIdx)
        
        isPPorNC = (compIdx != enumSynCompIdxs.netCon)
        
        if (isPPorNC) {
            mechType.select(mechIdx)
            mechType.selected(mechName)
        }
        for eachItemInList(syn, smAllSyns) {
            if (isPPorNC) {
                ppOrNetCon = syn.getPointProcess(enumPpRole)
                sefwNetConOrNil = nil
                maxVarType = 3
            } else {
                ppOrNetCon = syn.netCon
                if (seh.isSefwEnabled()) {
                    sefwNetConOrNil = syn.sefwNetCon
                }
                maxVarType = 1
            }
            for varType = 1, maxVarType {   // 1: "PARAMETER", 2: "ASSIGNED", 3: "STATE"
                varTypeIdx = varType - 1
                compMechStd = comp.mechStds[mechIdx][varTypeIdx]
                if (compMechStd == nil) {
                    continue
                }
                if (isPPorNC) {
                    _tempMechStdExt = new MechanismStandard(mechName, varType)
                } else {
                    execute("_tempMechStdExt = new FakeMechanismStandardForNetCon()", this)     // The template is not exported if !is3Or1PartInSynStruc_old
                }
                _tempMechStdExt.in(ppOrNetCon)
                mcu.copyAllVarsValuesExceptInhom(compMechStd, _tempMechStdExt)
                _tempMechStdExt.out(ppOrNetCon)
                if (sefwNetConOrNil != nil) {
                    _tempMechStdExt.out(sefwNetConOrNil)
                }
            }
            if (sefwNetConOrNil != nil) {
                sefwNetConOrNil.delay = 0
            }
        }
        _tempMechStdExt = nil
    }
    
endtemplate ReducedSynGroup

objref synGroup
synGroup = new ReducedSynGroup()
