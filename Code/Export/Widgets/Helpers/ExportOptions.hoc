
begintemplate ExportOptions

    public isExportDistMechs, isExportDistMechAssignedAndState, isExportDistMechInhoms, isExportDistMechStochs, isExportSyns, isExportSynAssignedAndState, isExportSynInhoms, isExportSynStochs, isCreateParamsHoc, isExposeModelVars, isCreateRunnerHoc, isRecordAndSaveModelVars, isMakeSweepForModelVars, isRepeatForStats, isCopyDll, isNewOrExistingDll
    public exposedVarsList, sweptVarsList, watchedVarsList
    public stdExposedVarsList
    public DtOrMinus1, isRecordAndSaveWithAPCounts, isSaveToTxtOrBinFile, numRepeatsForStats
    
    public validate
    public isExportAnyDistFuncs, isExportAnyStochFuncs, isExportAnyInhomBiophysModels, isExportSegmentationHelper, isExportAnyStochBiophysModels, isExportAnyInhomSynModels, isExportAnyStochSynModels, isExportInhomAndStochLibrary, isExportAltRunControl, isExportSynEventsHelper
    public isExportedInhomVar, isExportedStochVar, isExportedInhomBiophysVar, isExportedStochBiophysVar, isExportedInhomSynVar, isExportedStochSynVar
    public isPythonRequired
    public isAnyExposedVars, isAnySweptVars, isAnyWatchedVars
    public isAnyCustomSweptVars, isAnyWatchedAPCounts
    
    external cvode
    external isAstrocyteOrNeuron, soma_ref
    external inhomAndStochLibrary
    external pyObj, synGroup, seh
    external stringEmpty, codeContractViolation
    
    isExportDistMechs = -1
    isExportDistMechAssignedAndState = -1
    isExportDistMechInhoms = -1
    isExportDistMechStochs = -1
    isExportSyns = -1
    isExportSynAssignedAndState = -1
    isExportSynInhoms = -1
    isExportSynStochs = -1
    isCreateParamsHoc = -1
    isExposeModelVars = -1
    isCreateRunnerHoc = -1
    isRecordAndSaveModelVars = -1
    isMakeSweepForModelVars = -1
    isRepeatForStats = -1
    isCopyDll = -1
    isNewOrExistingDll = -1
    
    objref exposedVarsList, sweptVarsList, watchedVarsList
    objref stdExposedVarsList
    
    DtOrMinus1 = -1
    isRecordAndSaveWithAPCounts = -1
    isSaveToTxtOrBinFile = -1
    numRepeatsForStats = -1
    
    
    proc init() { local x localobj apc, nil
        strdef defWatchedVar, unitsStr
        
        // Default options
        isExportDistMechs = 1
        isExportDistMechAssignedAndState = 1
        isExportDistMechInhoms = 1
        isExportDistMechStochs = 1
        isExportSyns = !isAstrocyteOrNeuron
        isExportSynAssignedAndState = !isAstrocyteOrNeuron
        isExportSynInhoms = !isAstrocyteOrNeuron
        isExportSynStochs = !isAstrocyteOrNeuron
        isCreateParamsHoc = 0
        isExposeModelVars = 0
        isCreateRunnerHoc = 0
        isRecordAndSaveModelVars = 0
        isMakeSweepForModelVars = 0
        isRepeatForStats = 0
        isCopyDll = 1
        isNewOrExistingDll = 0
        
        exposedVarsList = new List()
        sweptVarsList = new List()
        watchedVarsList = new List()
        
        // Add one default watched variable
        apc = getFirstValidAPCountOrNil()
        if (apc != nil) {
            x = apc.get_loc()
            {
                sprint(defWatchedVar, "%s.v( %s )", secname(), pyObj.str(x))
            }
            pop_section()
        } else {
            soma_ref.o(0).sec {
                sprint(defWatchedVar, "%s.v( 0.5 )", secname())
            }
        }
        watchedVarsList.append(new String(defWatchedVar))
        
        // Default recording period
        if (!cvode.active()) {
            DtOrMinus1 = 4 * dt
        } else {
            DtOrMinus1 = -1
        }
        
        isRecordAndSaveWithAPCounts = 1
        isSaveToTxtOrBinFile = 1
        numRepeatsForStats = 2
        
        // Keep in sync with ExportManagerMainWidget.show
        stdExposedVarsList = new List()
        stdExposedVarsList.append(new ExposedOrSweptInputVar(1, 3, "celsius"))
        stdExposedVarsList.append(new ExposedOrSweptInputVar(1, 3, "v_init"))
        stdExposedVarsList.append(new ExposedOrSweptInputVar(1, 3, "tstop"))
        stdExposedVarsList.append(new ExposedOrSweptInputVar(1, 3, "dt"))
        // Always exporting "steps_per_ms" looks like overkill,
        // but in fact it's used by the standard "proc setdt()", so omitting it for export
        // would result in "Changed dt" when we run the exported file even though "dt" was exported
        stdExposedVarsList.append(new ExposedOrSweptInputVar(1, 3, "steps_per_ms", 1))
        
        unitsStr = units(&dt)
        if (!stringEmpty(unitsStr)) {
            sprint(unitsStr, "in model time, %s", unitsStr)
        }
        units(&DtOrMinus1, unitsStr)    // Do not replace with "units(&DtOrMinus1, units(&dt))"
    }
    
    // out: isCancel
    func validate() {
        if (isCreateRunnerHoc && (isAnySweptVars() || isRepeatForStats) && !(isAnyWatchedVars() || isAnyWatchedAPCounts())) {
            return !boolean_dialog("Are you sure want to proceed without specifying any watched variables?", "Yes", "No")
        }
        return 0
    }
    
    func isExportAnyDistFuncs() {
        return isExportAnyInhomBiophysModels() || isExportAnyInhomSynModels()
    }
    
    func isExportAnyStochFuncs() {
        return isExportAnyStochBiophysModels() || isExportAnyStochSynModels()
    }
    
    func isExportAnyInhomBiophysModels() {
        return (isExportDistMechs && isExportDistMechInhoms && inhomAndStochLibrary.getNumInhomVarsForDistMechs() != 0)
    }
    
    func isExportSegmentationHelper() {
        return (isExportDistMechs && isExportDistMechInhoms && inhomAndStochLibrary.isAnyNonVerbatimInhomVarsForDistMechs())
    }
    
    func isExportAnyStochBiophysModels() {
        return (isExportDistMechs && isExportDistMechStochs && inhomAndStochLibrary.getNumStochVarsForDistMechs() != 0)
    }
    
    func isExportAnyInhomSynModels() {
        return (isExportSyns && isExportSynInhoms && inhomAndStochLibrary.getNumInhomVarsForSyns() != 0)
    }
    
    func isExportAnyStochSynModels() {
        return (isExportSyns && isExportSynStochs && inhomAndStochLibrary.getNumStochVarsForSyns() != 0)
    }
    
    func isExportInhomAndStochLibrary() { local cond1, cond2
        cond1 = (isExportAnyDistFuncs() || isExportAnyStochFuncs() || isExportSynEventsHelper())
        if (isExportSyns) {
            cond2 = synGroup.is3Or1PartInSynStruc()
        } else {
            // synGroup is nil
            cond2 = 0
        }
        return cond1 || cond2
    }
    
    func isExportAltRunControl() {
        if (isExportAnyStochFuncs()) {
            return 1
        }
        if (isAstrocyteOrNeuron || !isExportSyns) {
            return 0
        }
        if (seh.isMinRPlt1) {
            return 1
        }
        return isReleaseProbabilityInExposedOrSweptVars()
    }
    
    func isExportSynEventsHelper() {
        if (isExportSyns) {
            if (seh.isSefwEnabled()) {
                return 1
            }
            return isReleaseProbabilityInExposedOrSweptVars()
        } else {
            // seh is nil
            return 0
        }
    }
    
    func isExportedInhomVar() { localobj activeSpecVar
        activeSpecVar = $o1
        if (!activeSpecVar.isInhom) {
            return 0
        }
        if (activeSpecVar.isDmOrSynPart) {
            if (!isExportDistMechs) {
                return 0
            }
            if (!isExportDistMechInhoms) {
                return 0
            }
            if (activeSpecVar.varType > 1 && !isExportDistMechAssignedAndState) {
                return 0
            }
        } else {
            if (isAstrocyteOrNeuron || !isExportSyns) {
                return 0
            }
            if (!isExportSynInhoms) {
                return 0
            }
            if (activeSpecVar.varType > 1 && !isExportSynAssignedAndState) {
                return 0
            }
        }
        return 1
    }
        
    func isExportedStochVar() { localobj activeSpecVar
        activeSpecVar = $o1
        if (!activeSpecVar.isStoch) {
            return 0
        }
        if (activeSpecVar.isDmOrSynPart) {
            if (!isExportDistMechs) {
                return 0
            }
            if (!isExportDistMechStochs) {
                return 0
            }
            if (activeSpecVar.varType > 1 && !isExportDistMechAssignedAndState) {
                return 0
            }
        } else {
            if (isAstrocyteOrNeuron || !isExportSyns) {
                return 0
            }
            if (!isExportSynStochs) {
                return 0
            }
            if (activeSpecVar.varType > 1 && !isExportSynAssignedAndState) {
                return 0
            }
        }
        return 1
    }
    
    func isExportedInhomBiophysVar() { localobj activeSpecVar
        activeSpecVar = $o1
        // 1: "PARAMETER"
        return isExportDistMechs && activeSpecVar.isInhom && activeSpecVar.isDmOrSynPart && (activeSpecVar.varType == 1 || isExportDistMechAssignedAndState)
    }
    
    func isExportedStochBiophysVar() { localobj activeSpecVar
        activeSpecVar = $o1
        // 1: "PARAMETER"
        return isExportDistMechs && activeSpecVar.isStoch && activeSpecVar.isDmOrSynPart && (activeSpecVar.varType == 1 || isExportDistMechAssignedAndState)
    }
    
    func isExportedInhomSynVar() { localobj activeSpecVar
        activeSpecVar = $o1
        // 1: "PARAMETER"
        return isExportSyns && activeSpecVar.isInhom && !activeSpecVar.isDmOrSynPart && (activeSpecVar.varType == 1 || isExportSynAssignedAndState)
    }
    
    func isExportedStochSynVar() { localobj activeSpecVar
        activeSpecVar = $o1
        // 1: "PARAMETER"
        return isExportSyns && activeSpecVar.isStoch && !activeSpecVar.isDmOrSynPart && (activeSpecVar.varType == 1 || isExportSynAssignedAndState)
    }
    
    func isPythonRequired() { local cond1, cond2, cond3, cond4, cond5
        // The exported file will require Python only if we export any inhom/stoch models requiring Python or we export FakeMechanismStandardForNetCon
        cond1 = (isExportDistMechs && isExportDistMechInhoms && inhomAndStochLibrary.doesAnyInhomVarRequirePython(1, isExportDistMechAssignedAndState))
        cond2 = (isExportSyns && isExportSynInhoms && inhomAndStochLibrary.doesAnyInhomVarRequirePython(0, isExportSynAssignedAndState))
        cond3 = (isExportDistMechStochs && inhomAndStochLibrary.doesAnyStochVarRequirePython(1, isExportDistMechAssignedAndState))
        cond4 = (isExportSynStochs && inhomAndStochLibrary.doesAnyStochVarRequirePython(0, isExportSynAssignedAndState))
        if (isExportSyns) {
            cond5 = synGroup.is3Or1PartInSynStruc()
        } else {
            // synGroup is nil
            cond5 = 0
        }
        return cond1 || cond2 || cond3 || cond4 || cond5
    }
    
    func isAnyExposedVars() {
        return (isCreateParamsHoc && isExposeModelVars && exposedVarsList.count() != 0)
    }
    
    func isAnySweptVars() {
        return (isCreateRunnerHoc && isMakeSweepForModelVars && sweptVarsList.count() != 0)
    }
    
    func isAnyWatchedVars() {
        // No need to start with "isCreateRunnerHoc && " as long as this func is called only from py:GensForRunnerHoc
        return (isRecordAndSaveModelVars && watchedVarsList.count() != 0)
    }
    
    func isAnyCustomSweptVars() { local sweptVarIdx, enumSpDmCeSt
        if (!isAnySweptVars()) {
            return 0
        }
        for sweptVarIdx = 0, sweptVarsList.count() - 1 {    // Don't replace with "eachItemInList" because we return
            enumSpDmCeSt = sweptVarsList.o(sweptVarIdx).enumSpDmCeSt
            if (enumSpDmCeSt == 2) {
                return 1
            } else if (enumSpDmCeSt == 3) {
                codeContractViolation()
            }
        }
        return 0
    }
    
    // Keep the filtration logic in sync with getFirstValidAPCountOrNil and py:GeneratorsForMainHocFile.createAPCounts
    func isAnyWatchedAPCounts() { local apcIdx localobj apcList
        if (!(isCreateRunnerHoc && isRecordAndSaveModelVars && isRecordAndSaveWithAPCounts)) {
            return 0
        }
        apcList = new List("APCount")
        if (apcList.count() == 0) {
            return 0
        }
        for apcIdx = 0, apcList.count() - 1 {   // Don't replace with "eachItemInList" because we return
            if (apcList.o(apcIdx).has_loc()) {
                return 1
            }
        }
        return 0
    }
    
    // All next staff is private
    
    
    func isReleaseProbabilityInExposedOrSweptVars() { local varIdx
        if (isCreateParamsHoc && isExposeModelVars) {
            for varIdx = 0, exposedVarsList.count() - 1 {   // Don't replace with "eachItemInList" because we return
                if (exposedVarsList.o(varIdx).isReleaseProbability()) {
                    return 1
                }
            }
        }
        if (isCreateRunnerHoc && isMakeSweepForModelVars) {
            for varIdx = 0, sweptVarsList.count() - 1 {     // The same comment
                if (sweptVarsList.o(varIdx).isReleaseProbability()) {
                    return 1
                }
            }
        }
        return 0
    }
    
    // Keep the filtration logic in sync with isAnyWatchedAPCounts and py:GeneratorsForMainHocFile.createAPCounts
    obfunc getFirstValidAPCountOrNil() { local apcIdx localobj apcList, nil, apc
        apcList = new List("APCount")
        if (apcList.count() == 0) {
            return nil
        }
        for apcIdx = 0, apcList.count() - 1 {   // Don't replace with "eachItemInList" because we return
            apc = apcList.o(apcIdx)
            if (apc.has_loc()) {
                return apc
            }
        }
        return nil
    }
    
endtemplate ExportOptions


objref exportOptions
