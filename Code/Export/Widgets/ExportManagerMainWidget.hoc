
begintemplate ExportOptions

    public isExportDistMechs, isExportDistMechInhoms, isExportDistMechStochs, isExportSyns, isExportSynInhoms, isExportSynStochs, isCreateParamsHoc, isExposeModelVars, isCreateRunnerHoc, isRecordAndSaveModelVars, isMakeSweepForModelVars, isCopyDll, isNewOrExistingDll
    public isExportInhomModels, isExportStochModels
    
    external isAstrocyteOrNeuron
    external inhomAndStochLibrary
    
    isExportDistMechs = -1
    isExportDistMechInhoms = -1
    isExportDistMechStochs = -1
    isExportSyns = -1
    isExportSynInhoms = -1
    isExportSynStochs = -1
    isCreateParamsHoc = -1
    isExposeModelVars = -1
    isCreateRunnerHoc = -1
    isRecordAndSaveModelVars = -1
    isMakeSweepForModelVars = -1
    isCopyDll = -1
    isNewOrExistingDll = -1
    
    
    proc init() {
        isExportDistMechs = 1
        isExportDistMechInhoms = 1
        isExportDistMechStochs = 1
        isExportSyns = 1
        isExportSynInhoms = 1
        isExportSynStochs = 1
        isCreateParamsHoc = 0
        isExposeModelVars = 0
        isCreateRunnerHoc = 0
        isRecordAndSaveModelVars = 0
        isMakeSweepForModelVars = 0
        isCopyDll = 0
        isNewOrExistingDll = 0
    }
    
    func isExportInhomModels() { local biophysCond, synCond
        biophysCond = (isExportDistMechs && isExportDistMechInhoms && inhomAndStochLibrary.getNumInhomVarsForDistMechs() != 0)
        synCond = (!isAstrocyteOrNeuron && isExportSyns && isExportSynInhoms && inhomAndStochLibrary.getNumInhomVarsForSyns() != 0)
        return biophysCond || synCond
    }
    
    func isExportStochModels() { local biophysCond, synCond
        biophysCond = (isExportDistMechs && isExportDistMechStochs && inhomAndStochLibrary.getNumStochVarsForDistMechs() != 0)
        synCond = (!isAstrocyteOrNeuron && isExportSyns && isExportSynStochs && inhomAndStochLibrary.getNumStochVarsForSyns() != 0)
        return biophysCond || synCond
    }
    
endtemplate ExportOptions

objref exportOptions
exportOptions = new ExportOptions()


begintemplate ExportManagerMainWidget

    public show, dismissHandler
    
    external mwh, compUtils, inhomAndStochLibrary
    external saveNanoHocFile, createEmptyPanel, openDeck, closeDeck, unmapIfNotNil
    external isAstrocyteOrNeuron
    external exportOptions
    
    objref mainBox, deck1, deck2, deck3, deck4, deck5
    objref clovWidgets[1]
    
    numClovWidgets = -1
    
    firstColWidth = -1
    secondColWidth = -1
    slotHeight = -1
    
    
    proc init() {
        numClovWidgets = 3
        
        objref clovWidgets[numClovWidgets]
        clovWidgets[0] = new CreateListOfInputVarsWidget(0)
        clovWidgets[1] = new CreateListOfOutputVarsWidget()
        clovWidgets[2] = new CreateListOfInputVarsWidget(1)
        
        firstColWidth = 140
        secondColWidth = 450
        slotHeight = 50
    }
    
    proc show() { local numInhomVars, numStochVars localobj hBox, deck
        
        compUtils.makeSureAllCompsCreated()     // Needed for AddOneInputVarWidget
        
        mainBox = new VBox()
        mainBox.intercept(1)
        {
            xpanel("")
            xlabel("The minimum exported data include all topology and geometry (with nanogeometry).")
            xlabel("Please choose what other data must be exported:")
            xpanel()
            hBox = new HBox()
            hBox.intercept(1)
            {
                // It turns out, the usage of Deck-s with just 1 card everywhere in the left column
                // gives a nicer UI compared to other options (VBox, HBox or no-box)
                deck = openDeck()
                {
                    xpanel("")
                    xcheckbox("All biophysics", &exportOptions.isExportDistMechs, "distMechsCheckBoxHandler()")
                    xpanel()
                }
                closeDeck(deck, 0, firstColWidth, slotHeight)
                numInhomVars = inhomAndStochLibrary.getNumInhomVarsForDistMechs()
                numStochVars = inhomAndStochLibrary.getNumStochVarsForDistMechs()
                deck1 = createInhomStochDeck(numInhomVars, numStochVars, &exportOptions.isExportDistMechInhoms, &exportOptions.isExportDistMechStochs, exportOptions.isExportDistMechs)
            }
            hBox.intercept(0)
            hBox.map()
            if (!isAstrocyteOrNeuron) {
                hBox = new HBox()
                hBox.intercept(1)
                {
                    deck = openDeck()
                    {
                        xpanel("")
                        xcheckbox("All synapses", &exportOptions.isExportSyns, "synsCheckBoxHandler()")
                        xpanel()
                    }
                    closeDeck(deck, 0, firstColWidth, slotHeight)
                    numInhomVars = inhomAndStochLibrary.getNumInhomVarsForSyns()
                    numStochVars = inhomAndStochLibrary.getNumStochVarsForSyns()
                    deck2 = createInhomStochDeck(numInhomVars, numStochVars, &exportOptions.isExportSynInhoms, &exportOptions.isExportSynStochs, exportOptions.isExportSyns)
                }
                hBox.intercept(0)
                hBox.map()
            }
            xpanel("")
            xlabel("")
            xlabel("Please choose what other files must be created or copied:")
            xpanel()
            hBox = new HBox()
            hBox.intercept(1)
            {
                deck = openDeck()
                {
                    xpanel("")
                    xcheckbox("Create \"params.hoc\"", &exportOptions.isCreateParamsHoc, "createParamsHocCheckBoxHandler()")
                    xpanel()
                }
                closeDeck(deck, 0, firstColWidth, 2 * slotHeight)
                deck3 = openDeck()
                {
                    createEmptyPanel()
                    xpanel("")
                    xlabel("By default, the file will contain the following general settings:")
                    xlabel("    ENABLE_GRAPHICAL_INTERFACE, SHOW_TOPOLOGY, ENABLE_AUTORUN, ENABLE_AUTOEXIT")
                    xlabel("and general simulation params:")
                    xlabel("    DT, TSTART, TSTOP")
                    xcheckbox("Expose some vars (I will select them)", &exportOptions.isExposeModelVars, "varsSelectorCheckBoxHandler(0, exportOptions.isExposeModelVars)")
                    xpanel()
                }
                closeDeck(deck3, exportOptions.isCreateParamsHoc, secondColWidth, 2 * slotHeight)
            }
            hBox.intercept(0)
            hBox.map()
            hBox = new HBox()
            hBox.intercept(1)
            {
                deck = openDeck()
                {
                    xpanel("")
                    xcheckbox("Create \"runner.hoc\"", &exportOptions.isCreateRunnerHoc, "createRunnerHocCheckBoxHandler()")
                    xpanel()
                }
                closeDeck(deck, 0, firstColWidth, slotHeight)
                deck4 = openDeck()
                {
                    createEmptyPanel()
                    xpanel("")
                    xcheckbox("Record and save some vars (I will select them)", &exportOptions.isRecordAndSaveModelVars, "varsSelectorCheckBoxHandler(1, exportOptions.isRecordAndSaveModelVars)")
                    xcheckbox("Make a sweep for some vars (I will select them and define the grids)", &exportOptions.isMakeSweepForModelVars, "varsSelectorCheckBoxHandler(2, exportOptions.isMakeSweepForModelVars)")
                    xpanel()
                }
                closeDeck(deck4, exportOptions.isCreateRunnerHoc, secondColWidth, slotHeight)
            }
            hBox.intercept(0)
            hBox.map()
            hBox = new HBox()
            hBox.intercept(1)
            {
                deck = openDeck()
                {
                    xpanel("")
                    xcheckbox("Copy \"nrnmech.dll\"", &exportOptions.isCopyDll, "copyDllCheckBoxHandler()")
                    xpanel()
                }
                closeDeck(deck, 0, firstColWidth, slotHeight)
                deck5 = openDeck()
                {
                    createEmptyPanel()
                    xpanel("")
                    xradiobutton("Copy the existing DLL (it may contain some unused mechs)", "copyDllRadioButtonHandler(0)", exportOptions.isNewOrExistingDll == 0)
                    xradiobutton("Build and copy a new DLL (it will contain only used mechs)", "copyDllRadioButtonHandler(1)", exportOptions.isNewOrExistingDll == 1)
                    xpanel()
                }
                closeDeck(deck5, exportOptions.isCopyDll, secondColWidth, slotHeight)
            }
            hBox.intercept(0)
            hBox.map()
            xpanel("")
            xlabel("")
            xbutton("Export", "exportHandler()")
            xpanel()
        }
        mainBox.intercept(0)
        mainBox.dismiss_action("dismissHandler()")
        mainBox.map("Manager of export", 60, 100, -1, -1)
    }
    
    proc dismissHandler() {
        dismissChilds()
        unmapIfNotNil(mainBox)
    }
    
    // All next staff is private
    
    
    obfunc createInhomStochDeck() { local numInhomVars, numStochVars, cardIdx localobj deck
        strdef text
        
        numInhomVars = $1
        numStochVars = $2
        cardIdx = $5
        
        deck = openDeck()
        {
            createEmptyPanel()
            xpanel("")
            sprint(text, "With inhom vars (%d detected)", numInhomVars)
            xcheckbox(text, &$&3)
            sprint(text, "With stoch vars (%d detected)", numStochVars)
            xcheckbox(text, &$&4)
            xpanel()
        }
        closeDeck(deck, cardIdx, secondColWidth, slotHeight)
        
        return deck
    }
    
    proc distMechsCheckBoxHandler() {
        deck1.flip_to(exportOptions.isExportDistMechs)
    }
    
    proc synsCheckBoxHandler() {
        deck2.flip_to(exportOptions.isExportSyns)
    }
    
    proc createParamsHocCheckBoxHandler() {
        deck3.flip_to(exportOptions.isCreateParamsHoc)
    }
    
    proc varsSelectorCheckBoxHandler() { local clovWidIdx, isChecked
        clovWidIdx = $1
        isChecked = $2
        dismissChilds()
        if (isChecked) {
            clovWidgets[clovWidIdx].show()
        }
    }
    
    proc createRunnerHocCheckBoxHandler() {
        deck4.flip_to(exportOptions.isCreateRunnerHoc)
    }
    
    proc copyDllCheckBoxHandler() {
        deck5.flip_to(exportOptions.isCopyDll)
    }
    
    proc copyDllRadioButtonHandler() {
        exportOptions.isNewOrExistingDll = $1
    }
    
    proc exportHandler() { local isCancel
        /* !!
        if (exportOptions.isExportDistMechs || exportOptions.isExportSyns || exportOptions.isCreateParamsHoc || exportOptions.isCreateRunnerHoc || exportOptions.isCopyDll) {
            mwh.showNotImplementedWarning()
            return
        }
        */
        
        isCancel = saveNanoHocFile()
        if (isCancel) {
            return
        }
        
        dismissHandler()
    }
    
    proc dismissChilds() { local clovWidIdx
        for clovWidIdx = 0, numClovWidgets - 1 {
            clovWidgets[clovWidIdx].dismissHandler()
        }
    }
    
endtemplate ExportManagerMainWidget

objref exportManagerMainWidget
exportManagerMainWidget = new ExportManagerMainWidget()
