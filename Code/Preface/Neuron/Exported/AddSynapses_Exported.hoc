
// !! get rid of this once Syn Manager is ready
// objref DistanceDistribution  // This was not used

begintemplate Synapse

    public source, netCon, target, single, sec_ref, connectionPoint, dist
    public getPointProcess, changeLocation, changeStructure
    
    // !! uncomment here and below once it's exported
    // external codeContractViolation
    
    objref source, netCon, target, single, sec_ref
    
    connectionPoint = -1
    dist = -1
    
    
    proc init() { local numArg
        numArg = numarg()
        if (numArg == 5) {
            source = $o1
            netCon = $o2
            target = $o3
            sec_ref = $o4
            connectionPoint = $5
        } else if (numArg == 3) {
            single = $o1
            sec_ref = $o2
            connectionPoint = $3
        } else {
            // codeContractViolation()
        }
        calcAndCacheDist()
    }
    
    obfunc getPointProcess() { local enumPpRole
        enumPpRole = $1     // 0: "Source PP", 1: "Target PP", 2: "Single PP"
        
        if (enumPpRole == 0) {
            return source
        } else if (enumPpRole == 1) {
            return target
        } else if (enumPpRole == 2) {
            return single
        } else {
            // codeContractViolation()
        }
    }
    
    proc changeLocation() {
        sec_ref = $o1
        connectionPoint = $2
        calcAndCacheDist()
    }
    
    proc changeStructure() { local numArg localobj nil
        numArg = numarg()
        if (numArg == 3) {
            netCon = $o2    // Destroying old NetCon first
            source = $o1
            target = $o3
            single = nil
        } else if (numArg == 1) {
            single = $o1
            netCon = nil
            source = nil
            target = nil
        } else {
            // codeContractViolation()
        }
    }
    
    // All next staff is private
    
    
    proc calcAndCacheDist() {
        sec_ref.sec {
            dist = distance(connectionPoint)
        }
    }
    
endtemplate Synapse

objref smAllSyns
smAllSyns = new List()

// Create and connect all synapses; the number of synapses is the same as the number of spines !!or less!!
// Inputs: SynapseLocationDendrite, weight, IntervalSynapticActivity, SwtichOn, noise (all taken from the top level)
proc CreateTheSynapticInput() { local synIdx, connectionPoint localobj source, target, sec_ref, netCon, synapse
    strdef whereConnected
    
    // !! this is not used anywhere outside
    SynapseNumber = nanoDistal_ref.count()
    
    for synIdx = 0, SynapseNumber - 1 {
        source = new NetStim()
        
        if (SynapseLocationDendrite) {
            // Synapse is connected to the centre of spine_head
            connectionPoint = 0.5
            nanoDistal_ref.o(synIdx).sec {
                target = new Exp2Syn(connectionPoint)
                sec_ref = new SectionRef()
            }
        } else {
            // Synapse is connected to the point on dendrite where spine_neck emerges
            nanoProximal_ref.o(synIdx).sec connectionPoint = parent_connection()
            nanoProximal_ref.o(synIdx).parent {
                target = new Exp2Syn(connectionPoint)
                sec_ref = new SectionRef()
            }
        }
        
        // !! get rid of this once Syn Manager is ready
        // DistanceDistribution.x = dist
        // print "distance = ", dist
        // Conductance depended on distance. The formula is the same for all calculations
        // ConDistance = 0.5125 + dist * 0.65 / 300
        ConDistance = 1
        
        netCon = new NetCon(source, target, 0, 0, weight * ConDistance)
        source.start = 2
        source.interval = IntervalSynapticActivity
        source.number = SwtichOn
        source.noise = noise
        
        synapse = new Synapse(source, netCon, target, sec_ref, connectionPoint)
        smAllSyns.append(synapse)
    }
    
    if (SynapseLocationDendrite) {
        whereConnected = "spine_head(0.5)"
    } else {
        whereConnected = "dendrite(where spine_neck emerges)"
    }
    printf("SynapseNumber=%d; each connected to: %s\n", SynapseNumber, whereConnected)
}

// Inputs: SynapseNumber, smAllSyns, weight, IntervalSynapticActivity, SwtichOn, noise (all taken from the top level)
proc ChangeTheSynapticInput() { local synIdx localobj synapse
    // !! use the iterator once it's exported
    // for eachItemInList(synapse, smAllSyns) {
    for synIdx = 0, SynapseNumber - 1 {
        synapse = smAllSyns.o(synIdx)
        synapse.netCon.weight = weight
        synapse.source.interval = IntervalSynapticActivity
        synapse.source.number = SwtichOn
        synapse.source.noise = noise
    }
}

// This proc will be called each time after neuron nanogeometry reseeding
proc Neuron_AddSynapses_reseed() {
    CreateTheSynapticInput()
    ChangeTheSynapticInput()
}

Neuron_AddSynapses_reseed()
