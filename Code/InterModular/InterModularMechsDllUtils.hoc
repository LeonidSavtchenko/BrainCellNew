
// Don't move this declaration to Export.hoc because we would read it as an empty string in this file
strdef loadedNanoHocFilePathName


proc loadDefaultMechsDllDependingOnCellType() {
    strdef basePath, subFolderName, dllPath
    
    if (isBaseOrNanoStart) {
        basePath = "Mechanisms"
    } else {
        sprint(basePath, "%sMechanisms", startDir)
    }
    _getCellName(subFolderName)
    sprint(dllPath, "%s/%s", basePath, subFolderName)
    _loadThisMechsDll(dllPath)
}

// This proc is called from the nanogeometry file when user loads it back into the main program
proc ifMissingInThisFolderThenLoadDefaultMechsDllDependingOnCellType() { local isMissing
    strdef pyCommand, dirPath, cellName, line2
    
    sprint(pyCommand, "'%s'.rsplit('/', 1)[0]", loadedNanoHocFilePathName)
    dirPath = pyObj.ev(pyCommand)
    sprint(pyCommand, "(exec('import os'), not os.path.exists('%s' + '/nrnmech.dll'))[1]", dirPath)
    isMissing = pyObj.ev(pyCommand)
    if (isMissing) {
        print "\n\n    Warning: There is no \"nrnmech.dll\" in the same folder with the loaded nanogeometry HOC file."
        _getCellName(cellName)
        sprint(line2, "             We will load our default DLL for %s cell type with no guarantee that it matches this HOC file.\n", cellName)
        print line2
        loadDefaultMechsDllDependingOnCellType()
    } else {
        _loadThisMechsDll(dllPath)
    }
}


proc _loadThisMechsDll() { local status
    strdef dllPath, pyCommand
    dllPath = $s1
    
    sprint(pyCommand, "import neuron;neuron.load_mechanisms('%s'.replace('/', '\\\\'))", dllPath)
    status = nrnpython(pyCommand)
    if (!status) {
        printMsgAndRaiseError("Failed to load \"nrnmech.dll\"")
    }
}

proc _getCellName() {
    if (isAstrocyteOrNeuron) {
        $s1 = "Astrocyte"
    } else {
        $s1 = "Neuron"
    }
}
