
begintemplate Synapse

    public srcPp, netCon, trgPp, sngPp, sefwPp, sefwNetCon, sec_ref, connectionPoint, dist
    public getPointProcess, changeLocation, changeStructure
    
    external codeContractViolation
    
    objref srcPp, netCon, trgPp, sngPp, sefwPp, sefwNetCon, sec_ref
    
    connectionPoint = -1
    dist = -1
    
    
    proc init() { local numArg
        numArg = numarg()
        if (numArg == 5) {
            srcPp = $o1
            netCon = $o2
            trgPp = $o3
            sec_ref = $o4
            connectionPoint = $5
        } else if (numArg == 3) {
            sngPp = $o1
            sec_ref = $o2
            connectionPoint = $3
        } else {
            codeContractViolation()
        }
        calcAndCacheDist()
    }
    
    obfunc getPointProcess() { local enumPpRoleExt localobj nil
        enumPpRoleExt = $1     // 0: "Source PP", 1: "Target PP", 2: "Single PP", 3: "Target PP or Single PP"
        
        if (enumPpRoleExt == 0) {
            return srcPp
        } else if (enumPpRoleExt == 1) {
            return trgPp
        } else if (enumPpRoleExt == 2) {
            return sngPp
        } else if (enumPpRoleExt == 3) {
            if (netCon != nil) {
                return trgPp
            } else {
                return sngPp
            }
        } else {
            codeContractViolation()
        }
    }
    
    proc changeLocation() {
        sec_ref = $o1
        connectionPoint = $2
        calcAndCacheDist()
    }
    
    proc changeStructure() { local numArg localobj nil
        numArg = numarg()
        if (numArg == 1) {
            // sngPp -> Section
            
            netCon = nil        // Destroying old NetCon-s before all connected PPs
            sefwNetCon = nil    //
            
            sngPp = $o1
            
            srcPp = nil
            trgPp = nil
            sefwPp = nil
        } else if (numArg == 3) {
            // srcPp -> netCon -> trgPp -> Section
            
            netCon = $o2        // Destroying old NetCon-s before all connected PPs
            sefwNetCon = nil    //
            
            srcPp = $o1
            trgPp = $o3
            
            sngPp = nil
            sefwPp = nil
        } else if (numArg == 5) {
            // srcPp -> netCon -> sefwPp -> sefwNetCon -> trgPp -> Section
            
            netCon = $o2        // Destroying old NetCon-s before all connected PPs
            sefwNetCon = $o4    //
            
            srcPp = $o1
            sefwPp = $o3
            trgPp = $o5
            
            sngPp = nil
        } else {
            codeContractViolation()
        }
    }
    
    // All next staff is private
    
    
    proc calcAndCacheDist() {
        sec_ref.sec {
            dist = distance(connectionPoint)
        }
    }
    
endtemplate Synapse

objref smAllSyns
smAllSyns = new List()


// This proc will be called each time after neuron nanogeometry reseeding
// Create and connect all default synapses; the number is the same as the number of spines
// Inputs (all taken from the top level): enumSynLoc, nanoDistal_ref, nanoProximal_ref
// !! major code dupl. with SynGroup.getNewSecRefConnectionPointAndSpineNeckDiam
proc Neuron_AddSynapses_reseed() { local defStart, defInterval, defNumber, defNoise, defDelay, defWeight, numSyns, synIdx, connectionPoint localobj srcPp, trgPp, sec_ref, np_ref, netCon, synapse
    
    // Default values for NetStim
    defStart = 2
    defInterval = 100
    defNumber = 1000
    defNoise = 1
    
    // Default values for NetCon
    defDelay = 0
    defWeight = 0.0002
    
    numSyns = nanoDistal_ref.count()
    
    if (enumSynLoc == 2) {
        enumSynLoc == 0     // !! 2: "Random" cannot be used for default synapses at the moment
    }
    
    for synIdx = 0, numSyns - 1 {
        srcPp = new NetStim()
        
        if (enumSynLoc == 0) {
            // Synapse is connected to the centre of spine_head
            connectionPoint = 0.5
            nanoDistal_ref.o(synIdx).sec {
                trgPp = new Exp2Syn(connectionPoint)
                sec_ref = new SectionRef()
            }
        } else if (enumSynLoc == 1) {
            // Synapse is connected to the point on dendrite where spine_neck emerges
            np_ref = nanoProximal_ref.o(synIdx)
            np_ref.sec {
                connectionPoint = parent_connection()
            }
            np_ref.parent {
                trgPp = new Exp2Syn(connectionPoint)
                sec_ref = new SectionRef()
            }
        }
        
        srcPp.start = defStart
        srcPp.interval = defInterval
        srcPp.number = defNumber
        srcPp.noise = defNoise
        
        netCon = new NetCon(srcPp, trgPp, 0, defDelay, defWeight)
        
        synapse = new Synapse(srcPp, netCon, trgPp, sec_ref, connectionPoint)
        smAllSyns.append(synapse)
    }
}

Neuron_AddSynapses_reseed()
