//////////////////// Table of contents ///////////////////////////////////
/*
    Line 16:            Swept vars
    Line 35:            Watched vars and recorder settings
    Line 54:            Utils
    Line 272:           Prerequisites
    Line 283:           Main part
*/
//////////////////////////////////////////////////////////////////////////

strdef runnedHocFileName, outFolderName, outFileNameTimestampFormat
runnedHocFileName = "Cell1.hoc"
outFolderName = "results"
outFileNameTimestampFormat = "%Y-%m-%d %H.%M.%S"

//////////////////// Start of swept vars /////////////////////////////////

objref sweptVarUserReadableNames
sweptVarUserReadableNames = new List()
{ sweptVarUserReadableNames.append(new String("Bio: Soma \\ morphology \\ PARAMETER \\ diam (um)")) }

// Bio: Soma \ morphology \ PARAMETER \ diam (um)
sweptVar1GridSize = 5
double sweptVar1Grid[sweptVar1GridSize]
sweptVar1Grid[0] = 20.0
sweptVar1Grid[1] = 65.0
sweptVar1Grid[2] = 110.0
sweptVar1Grid[3] = 155.0
sweptVar1Grid[4] = 200.0

totalNumSims = sweptVar1GridSize

//////////////////// End of swept vars ///////////////////////////////////

//////////////////// Start of watched vars and recorder settings /////////

objref watchedVarNames
watchedVarNames = new List()
{ watchedVarNames.append(new String("s.v( 0.05 )")) }

objref watchedVarUnits
watchedVarUnits = new List()
{ watchedVarUnits.append(new String("mV")) }

// We'll record the values only once per "numItersPerOneRecord" iterations (it must be a positive integer)
numItersPerOneRecord = 4

// Hint: use "%g" for compact format and "%.15e" for max precision
strdef oneValueFormat
oneValueFormat = "%-8.4g"

//////////////////// End of watched vars and recorder settings ///////////

//////////////////// Start of utils //////////////////////////////////////

// Print the message, print the call stack, raise the error
// $s1 - The message
proc printMsgAndRaiseError() {
    strdef msg
    sprint(msg, "\n\n    %s\n", $s1)
    execerror(msg)
}

strdef tempFolderName, tempHocFileName
tempFolderName = "temp_folder"
tempHocFileName = "last_cell_without_templates.hoc"

strdef tempHocFilePathName
{ sprint(tempHocFilePathName, "%s/%s", tempFolderName, tempHocFileName) }

// in: tempFolderName, runnedHocFileName, tempHocFilePathName, outFolderName (taken from the top level)
proc createTempHocFileWithoutTemplatesAndOutputFolder() { local status
    strdef pyCode
    
    pyCode = "import os\ntempFolderName = '%s'\nrunnedHocFileName = '%s'\ntempHocFilePathName = '%s'\noutFolderName = '%s'\ndef createOrCleanUpFolder(folderName):\n    if os.path.exists(folderName):\n        for fileName in os.listdir(folderName):\n            filePath = os.path.join(folderName, fileName)\n            os.remove(filePath)\n    else:\n        os.mkdir(folderName)\ndef createTempHocFileWithoutTemplates():\n    with open(runnedHocFileName, 'r') as inFile, open(tempHocFilePathName, 'w') as outFile:\n        isSkipBlock = False\n        for line in inFile:\n            if line.startswith('begintemplate'):\n                isSkipBlock = True\n            elif line.startswith('endtemplate'):\n                isSkipBlock = False\n            elif not isSkipBlock:\n                outFile.write(line)\ncreateOrCleanUpFolder(tempFolderName)\ncreateTempHocFileWithoutTemplates()\ncreateOrCleanUpFolder(outFolderName)"
    
    sprint(pyCode, pyCode, tempFolderName, runnedHocFileName, tempHocFilePathName, outFolderName)
    
    status = nrnpython(pyCode)
    if (!status) {
        printMsgAndRaiseError("Failed to create the temporary HOC file or the output folder")
    }
}

// in: tempFolderName (taken from the top level)
proc deleteTempFolder() { local status
    strdef pyCode
    
    sprint(pyCode, "import shutil\nshutil.rmtree('%s')", tempFolderName)
    
    status = nrnpython(pyCode)
    if (!status) {
        printMsgAndRaiseError("Failed to delete the temporary folder")
    }
}

numSweptVars = sweptVarUserReadableNames.count()

numWatchedVars = watchedVarNames.count()
objref recordedVecs[numWatchedVars]

// in: numWatchedVars, numRecs, recordedVecs, Dt, watchedVarNames (taken from the top level)
proc setUpVecsForRecording() { local watchedVarIdx
    strdef hocCommandTempl, hocCommand
    
    // This works fine for DMs, PPs and NetCon-s
    hocCommandTempl = "recordedVecs[%d].record(&%s, Dt)"
    
    // But according to NEURON docs, in some cases it is preferable to use the following command
    //  hocCommandTempl = "recordedVecs[%d].record(pointProcessObject, &%s, Dt)"
    
    for watchedVarIdx = 0, numWatchedVars - 1 {
        // This will be resized by NEURON to 0 size just after "run()", here we just allocate memory as they recommend
        recordedVecs[watchedVarIdx] = new Vector(numRecs)
        
        sprint(hocCommand, hocCommandTempl, watchedVarIdx, watchedVarNames.o(watchedVarIdx).s)
        execute(hocCommand)
    }
}

objref pyObj

// in: outFileNameTimestampFormat, outFolderName, numSweptVars, numWatchedVars, watchedVarNames, recordedVecs, Dt, oneValueFormat (taken from the top level)
proc saveRecordedVecs() { local watchedVarIdx, actNumRecs, recIdx, time localobj outFile
    strdef pyCommand, outFileName, outFilePathName, line, oneValueStr
    
    sprint(pyCommand, "(exec('import datetime'), datetime.datetime.now().strftime('vars %s.txt'))[1]", outFileNameTimestampFormat)
    outFileName = pyObj.ev(pyCommand)
    
    sprint(outFilePathName, "%s/%s", outFolderName, outFileName)
    outFile = new File()
    outFile.wopen(outFilePathName)
    
    // The swept var names and values
    if (numSweptVars != 0) {
        dumpSweptVarsToFileHeader(outFile)
    }
    
    // The watched var names
    line = "t"
    for watchedVarIdx = 0, numWatchedVars - 1 {
        sprint(line, "%s\t%s", line, watchedVarNames.o(watchedVarIdx).s)
    }
    outFile.printf("%s\n", line)
    
    // The watched var units
    sprint(line, "%s", units(&t))
    for watchedVarIdx = 0, numWatchedVars - 1 {
        sprint(line, "%s\t%s", line, watchedVarUnits.o(watchedVarIdx).s)
    }
    outFile.printf("%s\n", line)
    
    // This will be < numRecs if user stopped the cycle
    actNumRecs = recordedVecs[0].size()
    
    // The watched var data
    for recIdx = 0, actNumRecs - 1 {
        time = recIdx * Dt
        sprint(line, oneValueFormat, time)
        for watchedVarIdx = 0, numWatchedVars - 1 {
            sprint(oneValueStr, oneValueFormat, recordedVecs[watchedVarIdx].x[recIdx])
            sprint(line, "%s\t%s", line, oneValueStr)
        }
        outFile.printf("%s\n", line)
    }
    
    outFile.close()
}

_sweptVarValue = -1

// in: numSweptVars, sweptVarUserReadableNames (taken from the top level)
proc dumpSweptVarsToFileHeader() { local sweptVarIdx localobj outFile
    strdef sweptVarName, hocCommand
    
    outFile = $o1
    
    outFile.printf("\n")
    for sweptVarIdx = 0, numSweptVars - 1 {
        sprint(sweptVarName, "SWEPT_VAR_%d", sweptVarIdx + 1)
        sprint(hocCommand, "_sweptVarValue = %s", sweptVarName)
        execute(hocCommand)
        outFile.printf("%s = %.15e    // %s\n", sweptVarName, _sweptVarValue, sweptVarUserReadableNames.o(sweptVarIdx).s)   // !!!! max precision, but still not the same as in sweptVar*Grid
    }
    outFile.printf("\n")
}

// Just some declarations for binding in the proc-s below (will be defined before the first usage)
numWatchedAPCounts = -1
objref apcList, recordedVecsFromAPCounts[1]

// in: numWatchedAPCounts, apcList, recordedVecsFromAPCounts (taken from the top level)
proc setUpVecsForRecordingFromAPCounts() { local apcIdx localobj vec
    for apcIdx = 0, numWatchedAPCounts - 1 {
        vec = new Vector()
        apcList.o(apcIdx).record(vec)
        recordedVecsFromAPCounts[apcIdx] = vec
    }
}

objref pyObj

// in: outFileNameTimestampFormat, outFolderName, numSweptVars, numWatchedAPCounts, apcList, recordedVecsFromAPCounts, oneValueFormat (taken from the top level)
proc saveRecordedVecsFromAPCounts() { local apcIdx, maxNumRecs, n, recIdx localobj outFile, vec
    strdef pyCommand, outFileName, outFilePathName, line, unitsStr, oneValueStr
    
    sprint(pyCommand, "(exec('import datetime'), datetime.datetime.now().strftime('aps %s.txt'))[1]", outFileNameTimestampFormat)
    outFileName = pyObj.ev(pyCommand)
    
    sprint(outFilePathName, "%s/%s", outFolderName, outFileName)
    outFile = new File()
    outFile.wopen(outFilePathName)
    
    // The swept var names and values
    if (numSweptVars != 0) {
        dumpSweptVarsToFileHeader(outFile)
    }
    
    // The time var name
    line = "t"
    for apcIdx = 1, numWatchedAPCounts - 1 {
        sprint(line, "%s\tt", line)
    }
    outFile.printf("%s\n", line)
    
    // The time var units
    unitsStr = units(&t)
    sprint(line, "%s", unitsStr)
    for apcIdx = 1, numWatchedAPCounts - 1 {
        sprint(line, "%s\t%s", line, unitsStr)
    }
    outFile.printf("%s\n", line)
    
    maxNumRecs = -1
    for apcIdx = 0, numWatchedAPCounts - 1 {
        n = apcList.o(apcIdx).n
        if (n > maxNumRecs) {
            maxNumRecs = n
        }
    }
    
    // The recorded times of action potentials
    for recIdx = 0, maxNumRecs - 1 {
        
        // The first column
        vec = recordedVecsFromAPCounts[0]
        if (recIdx < vec.size()) {
            sprint(line, oneValueFormat, vec.x(recIdx))
        } else {
            line = ""
        }
        
        // All next columns
        for apcIdx = 1, numWatchedAPCounts - 1 {
            vec = recordedVecsFromAPCounts[apcIdx]
            if (recIdx < vec.size()) {
                sprint(oneValueStr, oneValueFormat, vec.x(recIdx))
                sprint(line, "%s\t%s", line, oneValueStr)
            } else {
                sprint(line, "%s\t", line)
            }
        }
        
        outFile.printf("%s\n", line)
    }
    
    outFile.close()
}

//////////////////// End of utils ////////////////////////////////////////

//////////////////// Start of prerequisites //////////////////////////////

if (!nrnpython("")) {
    printMsgAndRaiseError("Sorry, this HOC file requires Python for some operations. Please install Python.")
}

pyObj = new PythonObject()
{ nrnpython("ev = lambda arg : eval(arg)") }

//////////////////// End of prerequisites ////////////////////////////////

//////////////////// Start of main part //////////////////////////////////

createTempHocFileWithoutTemplatesAndOutputFolder()

print "\nIf you need to break the cycle by simulations, just Stop the current simulation.\n"

nrncontrolmenu()

simIdx = 1

for sweptVar1Idx = 0, sweptVar1GridSize - 1 {
    // Bio: Soma \ morphology \ PARAMETER \ diam
    SWEPT_VAR_1 = sweptVar1Grid[sweptVar1Idx]
    
    printf("Running simulation %d of %d ...\n", simIdx, totalNumSims)
    
    if (simIdx == 1) {
        load_file(runnedHocFileName)
        
        apcList = new List("APCount")
        numWatchedAPCounts = apcList.count()
        objref recordedVecsFromAPCounts[numWatchedAPCounts]
    } else {
        load_file(1, tempHocFilePathName)
    }
    
    // Letting NEURON change "dt" now rather than on start of the simulation,
    // so we can set up the recorders correctly
    setdt()
    
    // Both "dt" and "tstop" can be swept
    Dt = numItersPerOneRecord * dt
    numRecs = tstop / Dt + 1
    
    setUpVecsForRecording()
    
    setUpVecsForRecordingFromAPCounts()
    
    run()
    
    if (stoprun) {
        stop
    }
    
    if (simIdx != totalNumSims) {
        saveRecordedVecs()
        saveRecordedVecsFromAPCounts()
    }
    
    simIdx += 1
}

// This will save the vecs on the last iteration AND in case when user stops the cycle
saveRecordedVecs()
saveRecordedVecsFromAPCounts()

deleteTempFolder()

{ printf("\nComplete!\nThe results were saved to \"%s%s\"\n\n", getcwd(), outFolderName) }

//////////////////// End of main part ////////////////////////////////////