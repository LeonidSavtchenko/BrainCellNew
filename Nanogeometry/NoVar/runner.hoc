//////////////////// Table of contents ///////////////////////////////////
/*
    Line 16:            Swept vars and repetition settings
    Line 40:            Watched vars and recorder settings
    Line 65:            Utils
    Line 351:           Prerequisites
    Line 371:           Main part
*/
//////////////////////////////////////////////////////////////////////////

strdef runnedHocFileName, outFolderName, outFileNameTimestampFormat
runnedHocFileName = "NoVar.hoc"
outFolderName = "results"
outFileNameTimestampFormat = "%Y-%m-%d %H.%M.%S"

//////////////////// Start of swept vars and repetition settings /////////

objref sweptVarUserReadableNames
sweptVarUserReadableNames = new List()
{ sweptVarUserReadableNames.append(new String("Syn: Source PP \\ NetStim \\ PARAMETER \\ interval (ms)")) }

// Syn: Source PP \ NetStim \ PARAMETER \ interval (ms)
sweptVar1GridSize = 10
double sweptVar1Grid[sweptVar1GridSize]
sweptVar1Grid[0] = 5.0
sweptVar1Grid[1] = 15.0
sweptVar1Grid[2] = 25.0
sweptVar1Grid[3] = 35.0
sweptVar1Grid[4] = 45.0
sweptVar1Grid[5] = 55.0
sweptVar1Grid[6] = 65.0
sweptVar1Grid[7] = 75.0
sweptVar1Grid[8] = 85.0
sweptVar1Grid[9] = 95.0

totalNumSims = sweptVar1GridSize

//////////////////// End of swept vars and repetition settings ///////////

//////////////////// Start of watched vars and recorder settings /////////

objref watchedVarNames
watchedVarNames = new List()
{ watchedVarNames.append(new String("s.v( 0.05 )")) }

objref watchedVarUnits
watchedVarUnits = new List()
{ watchedVarUnits.append(new String("mV")) }

// Recording period (in model time, optional)
DtOrMinus1 = 0.4    // (ms)

// Format hints:
//  "%g"     - mid precision, jagged columns (compact format)
//  "%.15e"  - max precision, fixed column width (with exponent)
//  "%-8.4g" - low precision, fixed column width (left alignment)
//  "%8.4g"  - low precision, fixed column width (right alignment)
//  "%.15g"  - max precision, jagged columns (compact format, without ".0")
//  "@py"    - max precision, jagged columns (compact format, with ".0")
strdef oneValueFormat
oneValueFormat = "%-8.4g"

//////////////////// End of watched vars and recorder settings ///////////

//////////////////// Start of utils //////////////////////////////////////

// Print the message, print the call stack, raise the error
// $s1 - The message
proc printMsgAndRaiseError() {
    strdef msg
    sprint(msg, "\n\n    %s\n", $s1)
    execerror(msg)
}

strdef tempFolderName, tempHocFileName
tempFolderName = "temp_folder"
tempHocFileName = "last_cell_without_templates.hoc"

strdef tempHocFilePathName
{ sprint(tempHocFilePathName, "%s/%s", tempFolderName, tempHocFileName) }

// in: tempFolderName, runnedHocFileName, tempHocFilePathName, outFolderName (taken from the top level)
proc createTempHocFileWithoutTemplatesAndOutputFolder() { local status
    strdef isCreateTempHocFileWithoutTemplates, isCreateOrCleanUpOutFolder, pyCode
    
    isCreateTempHocFileWithoutTemplates = $s1
    isCreateOrCleanUpOutFolder = $s2
    
    pyCode = "import os\nisCreateTempHocFileWithoutTemplates = %s\nisCreateOrCleanUpOutFolder = %s\ntempFolderName = '%s'\nrunnedHocFileName = '%s'\ntempHocFilePathName = '%s'\noutFolderName = '%s'\ndef createOrCleanUpFolder(folderName):\n    if os.path.exists(folderName):\n        for fileName in os.listdir(folderName):\n            filePath = os.path.join(folderName, fileName)\n            os.remove(filePath)\n    else:\n        os.mkdir(folderName)\ndef createTempHocFileWithoutTemplates():\n    with open(runnedHocFileName, 'r') as inFile, open(tempHocFilePathName, 'w') as outFile:\n        isSkipBlock = False\n        for line in inFile:\n            if line.startswith('begintemplate'):\n                isSkipBlock = True\n            elif line.startswith('endtemplate'):\n                isSkipBlock = False\n            elif not isSkipBlock:\n                outFile.write(line)\nif isCreateTempHocFileWithoutTemplates:\n    createOrCleanUpFolder(tempFolderName)\n    createTempHocFileWithoutTemplates()\nif isCreateOrCleanUpOutFolder:\n    createOrCleanUpFolder(outFolderName)"
    
    sprint(pyCode, pyCode, isCreateTempHocFileWithoutTemplates, isCreateOrCleanUpOutFolder, tempFolderName, runnedHocFileName, tempHocFilePathName, outFolderName)
    
    status = nrnpython(pyCode)
    if (!status) {
        printMsgAndRaiseError("Failed to create the temporary HOC file or the output folder")
    }
}

// in: tempFolderName (taken from the top level)
proc deleteTempFolder() { local status
    strdef pyCode
    
    sprint(pyCode, "import shutil\nshutil.rmtree('%s')", tempFolderName)
    
    status = nrnpython(pyCode)
    if (!status) {
        printMsgAndRaiseError("Failed to delete the temporary folder")
    }
}

objref pyObj

strdef getTimestampPyCommand, timestamp
{ sprint(getTimestampPyCommand, "(exec('import datetime'), datetime.datetime.now().strftime('%s'))[1]", outFileNameTimestampFormat) }

// in: oneValueFormat, pyObj (taken from the top level)
proc oneValueToString() { local value
    value = $1
    if (strcmp(oneValueFormat, "@py") != 0) {
        sprint($s2, oneValueFormat, value)
    } else {
        $s2 = pyObj.str(value)
    }
}

numSweptVars = sweptVarUserReadableNames.count()

numWatchedVars = watchedVarNames.count()
objref recordedVarVecs[numWatchedVars]

objref recordedTimeVec

// in: DtOrMinus1, cvode, recordedVarVecs, recordedTimeVec, numWatchedVars, watchedVarNames (taken from the top level)
proc setUpVarVecsForRecording() { local numRecsOr0, watchedVarIdx
    strdef hocCommandTempl, hocCommand
    
    // Estimate the number of records taking into scope that both "dt" and "tstop" can be swept
    if (DtOrMinus1 != -1) {
        numRecsOr0 = int(tstop / DtOrMinus1 + 1) + 1
    } else if (!cvode.active()) {
        // Letting NEURON change "dt" now rather than on start of the simulation
        setdt()
        numRecsOr0 = int(tstop / dt + 1) + 1
    } else {
        numRecsOr0 = 0      // No estimate
    }
    
    // This works fine for any vars from DMs, PPs/ACs, NetCon-s and top-level vars
    if (DtOrMinus1 != -1) {
        hocCommandTempl = "recordedVarVecs[%d].record(&%s, DtOrMinus1)"
    } else {
        hocCommandTempl = "recordedVarVecs[%d].record(&%s)"
    }
    
    // But according to NEURON docs, in some cases it is preferable to use the following command
    //  hocCommandTempl = "recordedVarVecs[%d].record(pointProcessObject, &%s, [DtOrMinus1])"
    
    if (cvode.active() && DtOrMinus1 == -1) {
        recordedTimeVec = new Vector()
        recordedTimeVec.record(&t)
    }
    
    for watchedVarIdx = 0, numWatchedVars - 1 {
        // This will be resized by NEURON to 0 size just after "run()", here we just allocate memory as they recommend
        recordedVarVecs[watchedVarIdx] = new Vector(numRecsOr0)
        
        sprint(hocCommand, hocCommandTempl, watchedVarIdx, watchedVarNames.o(watchedVarIdx).s)
        execute(hocCommand)
    }
}

// in: outFolderName, timestamp, numSweptVars, numWatchedVars, watchedVarNames, recordedVarVecs, recordedTimeVec, DtOrMinus1 (taken from the top level)
proc saveRecordedVarVecs() { local watchedVarIdx, actNumRecs, recIdx, time localobj outFile
    strdef outFilePathName, line, oneValueStr
    
    sprint(outFilePathName, "%s/vars %s.txt", outFolderName, timestamp)
    outFile = new File()
    outFile.wopen(outFilePathName)
    
    // The swept var names and values
    if (numSweptVars != 0) {
        dumpSweptVarsToFileHeader(outFile)
    }
    
    // The watched var names
    line = "t"
    for watchedVarIdx = 0, numWatchedVars - 1 {
        sprint(line, "%s\t%s", line, watchedVarNames.o(watchedVarIdx).s)
    }
    outFile.printf("%s\n", line)
    
    // The watched var units
    sprint(line, "%s", units(&t))
    for watchedVarIdx = 0, numWatchedVars - 1 {
        sprint(line, "%s\t%s", line, watchedVarUnits.o(watchedVarIdx).s)
    }
    outFile.printf("%s\n", line)
    
    // For fixed time step method, this will be < numRecs if user stopped the cycle
    actNumRecs = recordedVarVecs[0].size()
    
    // The watched var data
    for recIdx = 0, actNumRecs - 1 {
        if (cvode.active() && DtOrMinus1 == -1) {
            time = recordedTimeVec.x(recIdx)
        } else if (DtOrMinus1 != -1) {
            time = recIdx * DtOrMinus1
        } else {
            time = recIdx * dt
        }
        oneValueToString(time, line)
        for watchedVarIdx = 0, numWatchedVars - 1 {
            oneValueToString(recordedVarVecs[watchedVarIdx].x[recIdx], oneValueStr)
            sprint(line, "%s\t%s", line, oneValueStr)
        }
        outFile.printf("%s\n", line)
    }
    
    outFile.close()
}

// Just some declarations for binding in the proc-s below (will be defined before the first usage)
numWatchedAPCounts = -1
objref apcList, recordedVecsFromAPCounts[1]

// in: numWatchedAPCounts, apcList, recordedVecsFromAPCounts (taken from the top level)
proc setUpVecsForRecordingFromAPCounts() { local apcIdx localobj vec
    for apcIdx = 0, numWatchedAPCounts - 1 {
        vec = new Vector()
        apcList.o(apcIdx).record(vec)
        recordedVecsFromAPCounts[apcIdx] = vec
    }
}

// in: outFolderName, timestamp, numSweptVars, numWatchedAPCounts, apcList, recordedVecsFromAPCounts (taken from the top level)
proc saveRecordedVecsFromAPCounts() { local apcIdx, maxNumRecs, n, recIdx localobj outFile, vec
    strdef outFilePathName, line, unitsStr, tempStr
    
    sprint(outFilePathName, "%s/aps %s.txt", outFolderName, timestamp)
    outFile = new File()
    outFile.wopen(outFilePathName)
    
    // The swept var names and values
    if (numSweptVars != 0) {
        dumpSweptVarsToFileHeader(outFile)
    }
    
    // The time var name
    line = "t"
    for apcIdx = 1, numWatchedAPCounts - 1 {
        sprint(line, "%s\tt", line)
    }
    outFile.printf("%s\n", line)
    
    // The time var units
    unitsStr = units(&t)
    sprint(line, "%s", unitsStr)
    for apcIdx = 1, numWatchedAPCounts - 1 {
        sprint(line, "%s\t%s", line, unitsStr)
    }
    outFile.printf("%s\n", line)
    
    // The locations of APCount-s
    getAPCountLocationHint(0, line)
    for apcIdx = 1, numWatchedAPCounts - 1 {
        getAPCountLocationHint(apcIdx, tempStr)
        sprint(line, "%s\t%s", line, tempStr)
    }
    outFile.printf("%s\n", line)
    
    // The thresholds of APCount-s
    getAPCountThresholdHint(0, line)
    for apcIdx = 1, numWatchedAPCounts - 1 {
        getAPCountThresholdHint(apcIdx, tempStr)
        sprint(line, "%s\t%s", line, tempStr)
    }
    outFile.printf("%s\n", line)
    
    maxNumRecs = -1
    for apcIdx = 0, numWatchedAPCounts - 1 {
        n = apcList.o(apcIdx).n
        if (n > maxNumRecs) {
            maxNumRecs = n
        }
    }
    
    // The recorded times of action potentials
    for recIdx = 0, maxNumRecs - 1 {
        
        // The first column
        vec = recordedVecsFromAPCounts[0]
        if (recIdx < vec.size()) {
            oneValueToString(vec.x(recIdx), line)
        } else {
            line = ""
        }
        
        // All next columns
        for apcIdx = 1, numWatchedAPCounts - 1 {
            vec = recordedVecsFromAPCounts[apcIdx]
            if (recIdx < vec.size()) {
                oneValueToString(vec.x(recIdx), tempStr)
                sprint(line, "%s\t%s", line, tempStr)
            } else {
                sprint(line, "%s\t", line)
            }
        }
        
        outFile.printf("%s\n", line)
    }
    
    outFile.close()
}

// in: apcList, pyObj (taken from the top level)
proc getAPCountLocationHint() { local apcIdx, x
    apcIdx = $1
    x = apcList.o(apcIdx).get_loc()
    {
        sprint($s2, "loc = %s( %s )", secname(), pyObj.str(x))
    }
    pop_section()
}

// in: apcList, pyObj (taken from the top level)
proc getAPCountThresholdHint() { local apcIdx
    apcIdx = $1
    sprint($s2, "thresh = %s (%s)", pyObj.str(apcList.o(apcIdx).thresh), units(&APCount[0].thresh))
}

_sweptVarValue = -1

// in: numSweptVars, pyObj, sweptVarUserReadableNames (taken from the top level)
proc dumpSweptVarsToFileHeader() { local sweptVarIdx localobj outFile
    strdef sweptVarName, hocCommand
    
    outFile = $o1
    
    outFile.printf("\n")
    for sweptVarIdx = 0, numSweptVars - 1 {
        sprint(sweptVarName, "SWEPT_VAR_%d", sweptVarIdx + 1)
        sprint(hocCommand, "_sweptVarValue = %s", sweptVarName)
        execute(hocCommand)
        outFile.printf("%s = %s    // %s\n", sweptVarName, pyObj.str(_sweptVarValue), sweptVarUserReadableNames.o(sweptVarIdx).s)
    }
    outFile.printf("\n")
}

//////////////////// End of utils ////////////////////////////////////////

//////////////////// Start of prerequisites //////////////////////////////

if (!nrnpython("")) {
    printMsgAndRaiseError("Sorry, this HOC file requires Python for some operations. Please install Python.")
}

pyObj = new PythonObject()
{ nrnpython("ev = lambda arg : eval(arg)") }

proc checkCVodePrerequisites() { localobj pc
    pc = new ParallelContext()
    if ((pc.nhost() > 1 || pc.nthread() > 1) && cvode.use_local_dt()) {
        printMsgAndRaiseError("This runner HOC file cannot be used given parallel context and CVode settings.")
        // To support this, we'll have to update setUpVarVecsForRecording to use CVode.record instead of Vector.record assuming each watched var to have individual recordedTimeVec,
        // but CVode.record seems not to work when we try to record a var from PP/AC or a top-level var
    }
}

//////////////////// End of prerequisites ////////////////////////////////

//////////////////// Start of main part //////////////////////////////////

createTempHocFileWithoutTemplatesAndOutputFolder("True", "True")

print "\nIf you need to break the cycle by simulations, just Stop the current simulation.\n"

nrncontrolmenu()

simIdx = 1

for sweptVar1Idx = 0, sweptVar1GridSize - 1 {
    // Syn: Source PP \ NetStim \ PARAMETER \ interval
    SWEPT_VAR_1 = sweptVar1Grid[sweptVar1Idx]
    
    printf("Running simulation %d of %d ...\n", simIdx, totalNumSims)
    
    if (simIdx == 1) {
        load_file(runnedHocFileName)
        
        checkCVodePrerequisites()
        
        apcList = new List("APCount")
        numWatchedAPCounts = apcList.count()
        objref recordedVecsFromAPCounts[numWatchedAPCounts]
    } else {
        load_file(1, tempHocFilePathName)
    }
    
    setUpVarVecsForRecording()
    
    setUpVecsForRecordingFromAPCounts()
    
    run()
    
    timestamp = pyObj.ev(getTimestampPyCommand)
    
    if (stoprun) {
        stop
    }
    
    if (simIdx != totalNumSims) {
        saveRecordedVarVecs()
        saveRecordedVecsFromAPCounts()
    }
    
    simIdx += 1
}

// Saving the vecs on the last iteration AND in case when user breaks the cycle by simulations
saveRecordedVarVecs()
saveRecordedVecsFromAPCounts()

deleteTempFolder()

strdef word
if (stoprun) {
    word = "Stopped"
} else {
    word = "Complete"
}
{ printf("\n%s!\nThe results were saved to \"%s%s\"\n\n", word, getcwd(), outFolderName) }

//////////////////// End of main part ////////////////////////////////////