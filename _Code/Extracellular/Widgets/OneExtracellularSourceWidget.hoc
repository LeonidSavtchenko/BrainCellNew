
// !!! BUG: Click "Create new (default)", move the source to a random position with mouse, click "Save", then click "Correct", click "Save" => no warning that such ECS already exists + the centre coordinates shown in the list will be truncated a bit. The same effect for radius (if we don't move the source, but change it's radius with mouse). UPD: This truncation happens when we expose the variable with "xpvalue". Idea 1: Try to call "doNotify" in "saveHandler". Idea 2: Try to play with "ivoc_style" (e.g. set max accuracy, show the widget, set old accuracy again)

// !!! BUG: the markers for different species are shown in the same colour (because it depends only on the species index within its category)
//          think about different marker styles for different species categories (e.g. dash circle, "+" marker, "x" marker etc.)

begintemplate OneExtracellularSourceWidget

    public show, onApplyInParentWidget, dismissHandler
    
    external stringsEqual, findItemInListByString, removeItemFromList, getGlobalVarsHint, createEmptyPanel, codeContractViolation
    external mwh, math, ecsLibrary, speciesLibrary, graphUtils
    external eachItemInList
    external soma_ref
    external fast_flush_list
    
    objref mainBox, deck1, deck2, deck3, decks4[1], deck5, deck6, decks7[1], deck8, plotShape
    objref parentWidget, ionGlobalsWidget, netStimParamsWidget
    
    objref spcCatsList, spcNamesList, srcShapesList, srcDynamicsList
    
    objref seriesInfo
    
    
    enumPointSphere = -1
    x = -1
    y = -1
    z = -1
    radius = -1
    
    // !!! maybe add enumStaticSwitchSpike here
    offsetTime = -1
    duration = -1
    isSeries = -1
    
    isDiffDependOnTemp = -1
    
    ss = -1
    pointCapacityRadius = -1    // !!! maybe use the same UI as for "radius": show below "shapes" list and edit with mouse
    numMolecules = -1
    delta_o = -1
    
    x_soma = -1
    y_soma = -1
    z_soma = -1
    
    viewDirIdx = -1
    whatToShowIdx = -1
    
    oldSrcIdxOrMinus1 = -1
    
    // !!!! create test_sec[1]
    
    slotIdx4GraphUtils = -1
    
    
    proc init() { local inf
        strdef unitsStr
        
        parentWidget = $o1
        
        objref decks4[2]
        
        spcCatsList = speciesLibrary.spcCatsList
        objref decks7[spcCatsList.count()]
        
        srcShapesList = new List()
        srcShapesList.append(new String("Conc. outside point source"))
        srcShapesList.append(new String("Conc. inside sphere"))
        
        srcDynamicsList = new List()
        srcDynamicsList.append(new String("Static"))
        srcDynamicsList.append(new String("On-Off"))
        srcDynamicsList.append(new String("Spike"))
        
        viewDirIdx = 0
        whatToShowIdx = 0
        
        unitsStr = units("L")
        units(&radius, unitsStr)
        units(&x, unitsStr)
        units(&y, unitsStr)
        units(&z, unitsStr)
        units(&x_soma, unitsStr)
        units(&y_soma, unitsStr)
        units(&z_soma, unitsStr)
        
        unitsStr = units("t")
        units(&offsetTime, unitsStr)
        units(&duration, unitsStr)
        
        units(&ss, "mM")
        units(&pointCapacityRadius, "um")
        units(&delta_o, "mM")
        
        inf = math.inf
        variable_domain(&radius, float_epsilon, inf)    // !!! keep the lower bound in sync with func capRadius
        variable_domain(&offsetTime, 0, inf)
        variable_domain(&duration, float_epsilon, inf)
        variable_domain(&ss, 0, inf)
        variable_domain(&pointCapacityRadius, 0, inf)
        variable_domain(&numMolecules, 0, inf)
        // Allowing negative values for delta_o just because user may want to create one sphere with +delta_o containing another smaller sphere inside with -delta_o => cancellation of diffusion in the smaller sphere
        // variable_domain(&delta_o, 0, inf)
        
        // Doing this, we achive that the name remains declared, so we can create and delete 3 sections dynamically later
        // !!!! test_sec[0] delete_section()
        
        ionGlobalsWidget = new GlobalsEditorWidget()
        netStimParamsWidget = new NetStimParamsWidget()
        
        slotIdx4GraphUtils = 1
    }
    
    proc show() { local numArg, spcCatIdx, speciesIdx, shapeIdx, enumStaticSwitchSpike, thisSpcCatIdx localobj oldECS, oldSpatialInfo, oldTemporalInfo, oldCapacityInfo, spcCat, thisSpcNamesList, speciesInfo, hBox, vBox, thisDeck, hBox2
        strdef text, diffVarName, pesMenuToolName
        
        numArg = numarg()
        if (numArg > 2) {
            codeContractViolation()
        }
        
        // !!! review the default spatialInfo and temporalInfo values below taking them from the legacy code
        
        spcCatIdx = 0
        speciesIdx = 0
        
        shapeIdx = 1
                            //          !!! was (in legacy Diffusion3D.hoc):
        x = 456.5           // um       !!!  -30
        y = 123.5           //          !!!  20
        z = 0               //          !!!  0
        radius = 111.5      //          !!!  10 (ReleaseRadius)
        
        enumStaticSwitchSpike = 1
        offsetTime = 2.3    // ms
        duration = 4.5      //
        isSeries = 0
        
        isDiffDependOnTemp = 0
        
        // !!! PotassiumDiffusion.mod ("point" shape, "static" dynamics)
        ss = 2.5                    // mM
        pointCapacityRadius = 25    // um           !!! was: 1
        
        // !!! PotassiumDiffusion.mod ("point" shape, "spike" dynamics)
        numMolecules = 1e4          //              !!! was: 10000
        
        // !!! (No MOD-file) ("sphere" shape)
        delta_o = 2.3               // mM
        
        seriesInfo = new ECSSeriesInfo()
        
        // !!!!
        spcNamesList = spcCatsList.o(spcCatIdx).spcNamesList
        
        if (numArg >= 1) {
            oldECS = $o1
            
            // !!! in this template below, use the same names as in ECSSpatialInfo and ECSTemporalInfo
            
            spcCatIdx = oldECS.spcCatIdx
            spcNamesList = spcCatsList.o(spcCatIdx).spcNamesList    // !!!! the same line appears three times in this file
            speciesIdx = findItemInListByString(spcNamesList, oldECS.species)   // !!! maybe use SpeciesLibrary.getSpeciesInsideCatIdxForColouring
            if (speciesIdx == -1) {
                codeContractViolation()
            }
            
            oldSpatialInfo = oldECS.spatialInfo
            shapeIdx = oldSpatialInfo.enumPointSphere
            x = oldSpatialInfo.x
            y = oldSpatialInfo.y
            z = oldSpatialInfo.z
            if (shapeIdx == 1) {
                radius = oldSpatialInfo.radiusOrMinus1
            }
            
            // !!! maybe move this code to a new proc in ECSTemporalInfo
            oldTemporalInfo = oldECS.temporalInfo
            enumStaticSwitchSpike = oldTemporalInfo.enumStaticSwitchSpike
            if (enumStaticSwitchSpike != 0) {
                offsetTime = oldTemporalInfo.offsetTimeOrMinus1
                isSeries = oldTemporalInfo.isSeriesOrMinus1
            }
            if (enumStaticSwitchSpike == 1) {
                duration = oldTemporalInfo.durationOrMinus1
            }
            
            // !!! maybe move this code to a new proc in ECSCapacityInfo
            oldCapacityInfo = oldECS.capacityInfo
            if (shapeIdx == 0) {
                if (enumStaticSwitchSpike < 2) {
                    ss = oldCapacityInfo.ssOrMinus1
                    pointCapacityRadius = oldCapacityInfo.pointCapacityRadiusOrMinus1
                } else if (enumStaticSwitchSpike == 2) {
                    numMolecules = oldCapacityInfo.numMoleculesOrMinus1
                } else {
                    codeContractViolation()
                }
            } else if (shapeIdx == 1) {
                delta_o = oldCapacityInfo.delta_oOrMinus1
            } else {
                codeContractViolation()
            }
            
            if (isSeries) {
                seriesInfo = new ECSSeriesInfo(oldECS.seriesInfoOrNil)
            }
        }
        
        if (numArg == 2) {
            oldSrcIdxOrMinus1 = $2
        } else {
            oldSrcIdxOrMinus1 = -1
        }
        
        getSomaCoords(&x_soma, &y_soma, &z_soma)    // !!! was: 0, 0, 0 (in legacy Diffusion3D.hoc)
        
        mainBox = new VBox()
        mainBox.intercept(1)
        {
            xpanel("")
            xlabel("No changes will be saved until you click the \"Save\" button.")
            getGlobalVarsHint("saved", text)
            xlabel(text)
            xpanel()
            hBox = new HBox()
            hBox.intercept(1)
            {
                vBox = new VBox()
                vBox.intercept(1)
                {
                    xpanel("")
                    xlabel("Species category:")
                    xpanel()
                    spcCatsList.browser("", "spcCatName")
                    spcCatsList.select_action("spcCatSelectHandler(hoc_ac_)")
                    xpanel("")
                    xlabel("Species name:")
                    xpanel()
                    deck1 = new Deck()
                    deck1.intercept(1)
                    {
                        for eachItemInList(spcCat, spcCatsList) {
                            thisSpcNamesList = spcCat.spcNamesList
                            thisSpcNamesList.browser("", "s")
                            thisSpcNamesList.select(0)  // Must be called only after ".browser"
                            thisSpcNamesList.select_action("spcNameSelectHandler(hoc_ac_)")
                        }
                    }
                    deck1.intercept(0)
                    deck1.map()
                    // deck1.flip_to(*)     // Will be done below in spcCatSelectHandler
                    xpanel("")
                    // !!! xbutton("Edit species", "editSpeciesHandler()")
                    xbutton("Add new species", "addNewSpeciesHandler()")
                    xpanel()
                }
                vBox.intercept(0)
                vBox.map("", 0, 0, 150, 50)     // !!!
                vBox = new VBox()
                vBox.intercept(1)
                {
                    xpanel("")
                    xlabel("Source shape:")
                    xpanel()
                    srcShapesList.browser("", "s")
                    srcShapesList.select_action("srcShapeSelectHandler(hoc_ac_)")
                    deck2 = new Deck()
                    deck2.intercept(1)
                    {
                        createEmptyPanel()
                        xpanel("")
                        xpvalue("Radius", &radius, 1, "updatePlotShape()")
                        xpanel()
                    }
                    deck2.intercept(0)
                    deck2.map()
                    // deck2.flip_to(*)     // Will be done below in srcShapeSelectHandler
                }
                vBox.intercept(0)
                vBox.map()
                vBox = new VBox()
                vBox.intercept(1)
                {
                    xpanel("")
                    xlabel("Source dynamics:")
                    xpanel()
                    srcDynamicsList.browser("", "s")
                    srcDynamicsList.select_action("srcDynamicsSelectHandler(hoc_ac_)")
                    deck3 = new Deck()
                    deck3.intercept(1)
                    {
                        decks4[0] = createDynamicsParamsDeck(0)
                        decks4[1] = createDynamicsParamsDeck(1)
                    }
                    deck3.intercept(0)
                    deck3.map()
                    // deck3.flip_to(*)     // Will be done below in updateDecks34
                    deck5 = new Deck()
                    deck5.intercept(1)
                    {
                        createEmptyPanel()
                        xpanel("")
                        xcheckbox("Make a series", &isSeries, "isSeriesChangedHandler()")
                        xpanel()
                    }
                    deck5.intercept(0)
                    deck5.map()
                    // deck5.flip_to(*)     // Will be done below in srcDynamicsSelectHandler
                }
                vBox.intercept(0)
                vBox.map()
                vBox = new VBox()
                vBox.intercept(1)
                {
                    // !!! think about moving this "Species GLOBAL-s" panel to a better place:
                    //     * in this widget below "Species name"
                    //     * to a new widget shown when user clicks "Edit species" button (commented above)
                    //     * to the parent widget (which will also contain the list of species and "Add new species" button)
                    xpanel("")
                    xlabel("Species GLOBAL-s:")
                    xpanel()
                    deck6 = new Deck()
                    deck6.intercept(1)
                    {
                        xpanel("")
                        createEditBaseConcButtonAndHint()
                        xpanel()
                        for thisSpcCatIdx = 0, spcCatsList.count() - 1 {
                            spcCat = spcCatsList.o(thisSpcCatIdx)
                            thisDeck = new Deck()
                            thisDeck.intercept(1)
                            {
                                for eachItemInList(speciesInfo, spcCat.spcInfoList) {
                                    xpanel("")
                                    createEditBaseConcButtonAndHint()
                                    sprint(diffVarName, "Diff_%s", speciesInfo.suffix)
                                    xpvalue(diffVarName, &speciesInfo.diff, 1)
                                    sprint(text, "Make %s depend on temperature", diffVarName)
                                    xcheckbox(text, &isDiffDependOnTemp, "isDiffDependOnTempChangedHandler()")
                                    xpanel()
                                }
                            }
                            thisDeck.intercept(0)
                            // thisDeck.flip_to(*)      // Will be done below in updateDecks67
                            thisDeck.map("", 0, 0, 1, 138)  // !!!
                            decks7[thisSpcCatIdx] = thisDeck
                        }
                    }
                    deck6.intercept(0)
                    deck6.map()
                    // deck6.flip_to(*)     // Will be done below in updateDecks67
                    xpanel("")
                    xlabel("Source capacity:")
                    xpanel()
                    deck8 = new Deck()
                    deck8.intercept(1)
                    {
                        createEmptyPanel()
                        xpanel("")
                        // !!! PotassiumDiffusion.mod ("point" shape, "static" dynamics)
                        xpvalue("ss", &ss, 1)
                        xpvalue("Radius", &pointCapacityRadius, 1)
                        xpanel()
                        xpanel("")
                        // !!! PotassiumDiffusion.mod ("point" shape, "spike" dynamics)
                        // !!! maybe add a handler to make it integer after each change
                        xpvalue("Num. molecules", &numMolecules, 1)
                        xpanel()
                        xpanel("")
                        // !!! (no MOD-file) ("sphere" shape)
                        xpvalue("Delta of conc.", &delta_o, 1)
                        xpanel()
                    }
                    deck8.intercept(0)
                    deck8.map()
                    // deck8.flip_to(*)     // Will be done below in srcDynamicsSelectHandler
                }
                vBox.intercept(0)
                vBox.map()
            }
            hBox.intercept(0)
            hBox.map()
            xpanel("")
            xlabel("Source location:")  // !!! maybe get rid of this label
            xpanel()
            hBox = new HBox()
            hBox.intercept(1)
            {
                vBox = new VBox()
                vBox.intercept(1)
                {
                    hBox2 = new HBox()
                    hBox2.intercept(1)
                    {
                        xpanel("")
                        xradiobutton("XY projection", "viewDirectionChangedHandler(0)", viewDirIdx == 0)
                        xradiobutton("ZY projection", "viewDirectionChangedHandler(1)", viewDirIdx == 1)
                        xradiobutton("XZ projection", "viewDirectionChangedHandler(2)", viewDirIdx == 2)
                        xpanel()
                        xpanel("")
                        xradiobutton("Show only this src for this species", "whatToShowChangedHandler(0)", whatToShowIdx == 0)
                        xradiobutton("Show all srcs for this species", "whatToShowChangedHandler(1)", whatToShowIdx == 1)
                        xradiobutton("Show all srcs for all species", "whatToShowChangedHandler(2)", whatToShowIdx == 2)
                        xpanel()
                    }
                    hBox2.intercept(0)
                    hBox2.map()
                    plotShape = new PlotShape()
                    // !!! plotShape.exec_menu("Shape Plot")    // this affects performance while positioning the source
                    
                    // plotShape.menu_remove("3D Rotate")       // !!! error here: menu_remove not a public member of PlotShape
                    
                    // !!!! maybe add a hint label: "Please don't use \"3D Rotate\""
                    
                    pesMenuToolName = "Position Extracellular Source"
                    plotShape.menu_tool(pesMenuToolName, "mouseEventsHandler")
                    graphUtils.addPlotDynamicsMenuItem(plotShape, slotIdx4GraphUtils, "Extracellular Concentration", "", 0)
                    
                    fast_flush_list.append(plotShape)
                }
                vBox.intercept(0)
                vBox.map()
                vBox = new VBox()
                vBox.intercept(1)
                {
                    hBox2 = new HBox()
                    hBox2.intercept(1)
                    {
                        xpanel("")
                        xpvalue("x", &x, 1, "updatePlotShape()")
                        xpvalue("y", &y, 1, "updatePlotShape()")
                        xpvalue("z", &z, 1, "updatePlotShape()")
                        xpanel()
                        xpanel("")
                        xpvalue("x_soma", &x_soma, 1, "xyzSomaChangedHandler()")
                        xpvalue("y_soma", &y_soma, 1, "xyzSomaChangedHandler()")
                        xpvalue("z_soma", &z_soma, 1, "xyzSomaChangedHandler()")
                        xpanel()
                    }
                    hBox2.intercept(0)
                    hBox2.map()
                    xpanel("")
                    xbutton("Calculate the overlapping area/volume and other stats", "calcStatsHandler()")
                    xlabel("")
                    xlabel("Hints: Click on the PlotShape to move the source,")
                    xlabel("           hold \"Shift\" to resize the sphere;")
                    xlabel("           don't use \"3D Rotate\" when positioning sources (toggle \"XY/ZY/XZ projection\" instead).")
                    xpanel()
                }
                vBox.intercept(0)
                vBox.map()
            }
            hBox.intercept(0)
            hBox.map()
            xpanel("")
            xbutton("Save", "saveHandler()")
            xpanel()
        }
        mainBox.intercept(0)
        mainBox.dismiss_action("dismissHandler()")
        makeSelectionsInLists(spcCatIdx, speciesIdx, shapeIdx, enumStaticSwitchSpike)   // !!! doing it before mainBox.map to avoid blinking in List-s and Deck-s
        viewDirectionChangedHandler(viewDirIdx, 1)                                      //
        mainBox.map("One extracellular source", 540, 35, -1, -1)   // !!!
        
        // This must be done only after mapping of the mainBox
        recenterAndRescalePlotShape()
        
        plotShape.exec_menu(pesMenuToolName)    // !!!
        
        if (isSeries) {
            netStimParamsWidget.show(seriesInfo.mechStd)
        }
        
        speciesLibrary.validateAndWarnUser()
    }
    
    proc onApplyInParentWidget() { localobj nil
        if (mainBox == nil) {
            return
        }
        
        plotShape.flush()
    }
    
    proc dismissHandler() { localobj nil
        if (mainBox == nil) {
            return
        }
        
        dismissChilds()
        
        if (enumPointSphere == 1) {
            // !!!! deleteTempSectionCross()
        }
        
        removeItemFromList(fast_flush_list, plotShape, 1)
        
        // !!!! graphUtils.unregister(slotIdx4GraphUtils)
        
        mainBox.unmap()
        mainBox = nil
    }
    
    // All next staff is private
    
    
    obfunc createDynamicsParamsDeck() { local isSeries_ localobj deck
        // !!!! for series, "Offset time" is superseded by "start" from the NetStim panel, so maybe we need to keep them in sync (in both directions),
        //      however, for series, when "noise" = 1, "start" is not 1st impulse time
        
        isSeries_ = $1
        
        deck = new Deck()
        deck.intercept(1)
        {
            // "static" dynamics
            createEmptyPanel()
            
            // "on-off" dynamics
            xpanel("")
            if (!isSeries_) {
                xpvalue("Offset time", &offsetTime, 1)
            }
            xpvalue("Duration", &duration, 1)
            xpanel()
            
            // "spike" dynamics
            xpanel("")
            if (!isSeries_) {
                xpvalue("Offset time", &offsetTime, 1)
            }
            xpanel()
        }
        deck.intercept(0)
        // deck.flip_to(*)  // Will be done downstream in updateDecks34
        deck.map()
        
        return deck
    }
    
    proc makeSelectionsInLists() { local spcCatIdx, speciesIdx, shapeIdx, enumStaticSwitchSpike
        spcCatIdx = $1
        speciesIdx = $2
        shapeIdx = $3
        enumStaticSwitchSpike = $4
        
        // !!! maybe after this I don't need spcNamesList.select and spcNameSelectHandler below
        spcCatsList.select(spcCatIdx)
        spcCatSelectHandler(spcCatIdx, 1)
        
        spcNamesList.select(speciesIdx)
        spcNameSelectHandler(speciesIdx)
        
        srcShapesList.select(shapeIdx)
        srcShapeSelectHandler(shapeIdx, 1)
        
        srcDynamicsList.select(enumStaticSwitchSpike)
        srcDynamicsSelectHandler(enumStaticSwitchSpike)
    }
    
    proc spcCatSelectHandler() { local numArg, spcCatIdx, isCalledFromShow, cardIdx, spcNameIdx
        numArg = numarg()
        
        if (numArg < 1 || numArg > 2) {
            codeContractViolation()
        }
        
        spcCatIdx = $1
        
        if (numArg == 2) {
            isCalledFromShow = $2
            if (isCalledFromShow != 1) {
                codeContractViolation()
            }
        } else {
            isCalledFromShow = 0
        }
        
        spcNamesList = spcCatsList.o(spcCatIdx).spcNamesList
        
        cardIdx = spcCatIdx
        deck1.flip_to(cardIdx)
        
        if (!isCalledFromShow) {
            spcNameIdx = spcNamesList.selected()
            spcNameSelectHandler(spcNameIdx)
        }
    }
    
    proc spcNameSelectHandler() { local spcNameIdx
        strdef rangeVarName
        
        spcNameIdx = $1
        
        ionGlobalsWidget.dismissHandler()
        
        updateDecks67()
        
        rangeVarName = spcNamesList.o(spcNameIdx).rangeVarName
        
        // !!! no error here if the RANGE variable doesn't exist (e.g. "clo")
        plotShape.variable(rangeVarName)
        
        updatePlotShape()
        
        // !!! if the RANGE variable doesn't exist, a click on the cell causes the error, e.g.: "Cannot find the symbol for  clo",
        //     but this error looks for good, so let's keep it
        graphUtils.varNamesWithIndex[slotIdx4GraphUtils] = new String(rangeVarName)
    }
    
    proc addNewSpeciesHandler() {
        strdef line1, line2, line3, line4, line5, line6, line7, line8, line9, line10, line11, line12, line13
        
        sprint(line1, "Adding a new species to use in the \"%s\" requires several steps:", parentWidget.title)
        line2 = "1. Close the BrainCell program."
        line3 = "2. Edit the special MOD file \"Mechanisms\\Common\\MOD files\\_ECDCalcAndConsHelper.mod\" following the instructions inside."
        line4 = "3. (Optional) Add a new MOD file or edit an old one under \"Mechanisms\\<cell_type>\\MOD files\" to define custom behaviour for the new ion;"
        line5 = "     here \"<cell_type>\" can be either \"Astrocyte\", \"Neuron\" or \"Common\" depending on the target cell type."
        line6 = "4. Launch the PS1 or BAT script \"Mechanisms\\Common\\build_astrocyte_&_neuron_mechs.<ps1/bat>\" and make sure it finishes without the errors."
        line7 = "5. Add a new record to the JSON file \"Mechanisms\\Settings\\diffusible_species.json\" following the Legend inside."
        line8 = "6. Start the BrainCell program."
        line9 = "Notes:"
        line10 = "The point 3 above can be skipped if:"
        line11 = "    * you just want to declare the new ion without implementing any custom behaviour (in this case, doing the point 2 is enough);"
        line12 = "    * you create a HOC-based ion (using \"make_mechanism()\" and \"ion_register()\") rather than a MOD-based ion"
        line13 = "       (however, we didn't test this workflow)."  // !!! test this; see also: ion_style()
        mwh.showMessageBox(line1, "", line2, line3, line4, line5, line6, line7, line8, "", line9, line10, line11, line12, line13, "", "Instructions")
        
        // !!! in the future, we can automate all the points above except the point 3
        //     (the point 5 will require some new widget where user can make the presets)
    }
    
    proc srcShapeSelectHandler() { local numArg, enumPointSphere_new, isCalledFromShow, cardIdx
    
        numArg = numarg()
        if (numArg < 1 || numArg > 2) {
            codeContractViolation()
        }
        
        enumPointSphere_new = $1
        
        if (numArg == 2) {
            isCalledFromShow = $2
            if (!isCalledFromShow) {
                codeContractViolation()
            }
        } else {
            isCalledFromShow = 0
        }
        
        if (!isCalledFromShow && enumPointSphere_new == enumPointSphere) {
            return
        }
        
        enumPointSphere = enumPointSphere_new
        
        cardIdx = enumPointSphere
        deck2.flip_to(cardIdx)
        
        srcDynamicsSelectHandler(srcDynamicsList.selected())    // -> updateDecks34(), updateDecks67()
        
        if (enumPointSphere == 0) {
            if (!isCalledFromShow) {
                // !!!! deleteTempSectionCross()
            }
        } else if (enumPointSphere == 1) {
            // Empty by design (updatePlotShape below will call createOrUpdateTempSectionCross)
        } else {
            codeContractViolation()
        }
        
        updatePlotShape()
    }
    
    proc updatePlotShape() { local x_screen, y_screen
        // !!! no need to convert each time user changes species, source shape, sphere radius or whatToShowIdx (just cache it)
        convertCoordsWorldToScreen(x, y, z, &x_screen, &y_screen)
        updateSrcMark(x_screen, y_screen)
    }
    
    proc srcDynamicsSelectHandler() { local selItemIdx, enumStaticSwitchSpike, cardIdx
        selItemIdx = $1
        
        updateDecks34()
        
        enumStaticSwitchSpike = selItemIdx
        cardIdx = (enumStaticSwitchSpike > 0)
        deck5.flip_to(cardIdx)
        if (cardIdx == 0) {
            netStimParamsWidget.dismissHandler()
        } else if (isSeries) {
            // !!! do I need to do the same when user changes src shape, species etc.?
            netStimParamsWidget.show(seriesInfo.mechStd)
        }
        
        updateDecks67()
        
        if (enumPointSphere == 0) {
            cardIdx = 1 + (enumStaticSwitchSpike == 2)
        } else if (enumPointSphere == 1) {
            cardIdx = 3
        } else {
            codeContractViolation()
        }
        deck8.flip_to(cardIdx)
    }
    
    proc isSeriesChangedHandler() {
        updateDecks34()
        
        if (isSeries) {
            netStimParamsWidget.show(seriesInfo.mechStd)
            // !!! maybe set MechanismStandard.action() to check if "number" is too high and show the warning
        } else {
            netStimParamsWidget.dismissHandler()
        }
    }
    
    proc editBaseConcHandler() { local spcNameIdx
        strdef ionMechName
        
        spcNameIdx = spcNamesList.selected()
        ionMechName = spcNamesList.o(spcNameIdx).ionMechName
        
        // !!!! a problem with the shown widget: unnecessary "i0" var is exposed (the base concentration inside the cell);
        //      would it be better just to add an "xpvalue" in this widget instead of showing the whole new one?
        ionGlobalsWidget.show(ionMechName, 1200, 250)
    }
    
    proc isDiffDependOnTempChangedHandler() {
        if (isDiffDependOnTemp) {
            mwh.showNotImplementedWarning()
        }
    }
    
    proc viewDirectionChangedHandler() { local numArg, isCalledFromShow
        numArg = numarg()
        if (numArg < 1 || numArg > 2) {
            codeContractViolation()
        }
        
        viewDirIdx = $1
        if (numArg == 2) {
            isCalledFromShow = $2
            if (isCalledFromShow != 1) {
                codeContractViolation()
            }
        } else {
            isCalledFromShow = 0
        }
        
        plotShape.rotate()                              // XY
        
        if (viewDirIdx == 0) {
            // Empty by design
        } else if (viewDirIdx == 1) {
            plotShape.rotate(0, 0, 0, 0, PI / 2, 0)     // ZY
        } else if (viewDirIdx == 2) {
            plotShape.rotate(0, 0, 0, PI / 2, 0, 0)     // XZ
        } else {
            codeContractViolation()
        }
        
        if (!isCalledFromShow) {
            updatePlotShape()
            recenterAndRescalePlotShape()
        }
    }
    
    proc whatToShowChangedHandler() {
        whatToShowIdx = $1
        updatePlotShape()
    }
    
    proc mouseEventsHandler() { local eventType, x_screen, y_screen, keystate, isMoveOrResize, xc_screen, yc_screen, radius_screen
        eventType = $1
        x_screen = $2
        y_screen = $3
        keystate = $4
        
        isMoveOrResize = (keystate != 2)    // 2: Shift
        if (isMoveOrResize) {
            updateSrcMark(x_screen, y_screen)
            convertCoordsScreenToWorld(x_screen, y_screen, &x, &y, &z)
        } else {
            if (enumPointSphere == 0) {
                return
            }
            
            convertCoordsWorldToScreen(x, y, z, &xc_screen, &yc_screen)
            radius_screen = sqrt((x_screen - xc_screen) ^ 2 + (y_screen - yc_screen) ^ 2)
            radius = convertRadiusScreenToWorld(radius_screen)
            
            plotShape.erase()
            updateSphereMark(xc_screen, yc_screen)
        }
    }
    
    // !!! BUG: this doesn't move the cell in case when soma_ref.o(0) is not the topological root;
    //          try to reuse "getNamesOfAllTopologicalRoots" from the Import module and operate on the root sections
    proc xyzSomaChangedHandler() { local x_soma_old, y_soma_old, z_soma_old, n, idx, delta_x, delta_y, delta_z localobj x_vec, y_vec, z_vec, diam_vec
    
        // !!! would it make sense to cache them rather than calculate each time?
        getSomaCoords(&x_soma_old, &y_soma_old, &z_soma_old)
        
        soma_ref.o(0).sec {
            n = n3d()
            
            x_vec = new Vector(n)
            y_vec = new Vector(n)
            z_vec = new Vector(n)
            diam_vec = new Vector(n)
            
            for idx = 0, n - 1 {
                x_vec.x(idx) = x3d(idx)
                y_vec.x(idx) = y3d(idx)
                z_vec.x(idx) = z3d(idx)
                diam_vec.x(idx) = diam3d(idx)
            }
            
            delta_x = x_soma - x_soma_old
            delta_y = y_soma - y_soma_old
            delta_z = z_soma - z_soma_old
            
            pt3dclear()
            for idx = 0, n - 1 {
                pt3dadd(x_vec.x(idx) + delta_x, y_vec.x(idx) + delta_y, z_vec.x(idx) + delta_z, diam_vec.x(idx))
            }
            
            // !!! is there any better way to move the cell in NEURON or, at least,
            //     can I use "pt3dchange" instead of "pt3dclear" + "pt3dadd"?
            //     to improve the current approach a bit, I can find the section with the minimum number of 3D points
            //     and use it instead of soma_ref.o(0).sec
        }
    }
    
    proc calcStatsHandler() {
        // !!!
        mwh.showNotImplementedWarning()
    }
    
    proc saveHandler() { local spcCatIdx
        strdef line1, line2
        
        spcCatIdx = spcCatsList.selected()
        
        if (spcCatsList.o(spcCatIdx).isUnrecSpcCat) {
            // !!! keep the text in sync with SpeciesLibrary.validateAndWarnUser
            line1 = "This ion cannot be used for the extracellular diffusion until \"installed\" properly."
            line2 = "Click \"Add new species\" button for the instructions."
            mwh.showWarningBox(line1, line2)
            return
        }
        
        mwh.startIntercepting()
        {
            saveHandlerCore(spcCatIdx)
        }
        mwh.endIntercepting()
    }
    
    proc saveHandlerCore() { local spcCatIdx, enumStaticSwitchSpike, isSeries_, maxNumImps, isUnique localobj newSpatialInfo, newTemporalInfo, newCapacityInfo, newECS
        strdef line1, line2, line3, line4, species
        
        spcCatIdx = $1
        
        enumStaticSwitchSpike = srcDynamicsList.selected()
        
        // When "Make a series" checkbox is hidden, consider it unchecked
        isSeries_ = isSeries && (enumStaticSwitchSpike != 0)
        
        if (isSeries_) {
            // !!!! hardcode: maybe 100 is enough to impact the performance significantly (need to test)
            // !!!! the constant must depend on whether we use "erfc" or not
            maxNumImps = 100
            if (seriesInfo.getNumImps() > maxNumImps) {
                sprint(line1, "For the series, you specified \"number\" > %d.", maxNumImps)
                line2 = "That's quite a high value which will result in low performance on late iterations."
                line3 = "For so many impulses, much better performance can be achieved with numerical integration"
                line4 = "of the diffusion PDE rather than summation of the closed-form solutions."
                // !!! especially for "point + on-off" and "point + spike"
                
                // !!!! for "sphere+switch", when all pulses have the same duration, we can implement a technique
                //      based on the "memory horizon" that would allow us to avoid growing cycles in MOD,
                //      but for "point + on-off" and "point + spike" we cannot just "forget" about the old pulses because they have quite heavy tails
                
                mwh.showNotImplementedWarning(line1, line2, line3, line4, "")
            }
        }
        
        if (enumPointSphere == 0) {
            newSpatialInfo = new ECSSpatialInfo(0, x, y, z)
        } else if (enumPointSphere == 1) {
            newSpatialInfo = new ECSSpatialInfo(1, x, y, z, radius)
        } else {
            codeContractViolation()
        }
        
        if (enumStaticSwitchSpike == 0) {
            newTemporalInfo = new ECSTemporalInfo(0)
        } else if (enumStaticSwitchSpike == 1) {
            newTemporalInfo = new ECSTemporalInfo(1, offsetTime, duration, isSeries)
        } else if (enumStaticSwitchSpike == 2) {
            newTemporalInfo = new ECSTemporalInfo(2, offsetTime, isSeries)
        } else {
            codeContractViolation()
        }
        
        if (enumPointSphere == 0) {
            if (enumStaticSwitchSpike < 2) {
                newCapacityInfo = new ECSCapacityInfo(0, 0, ss, pointCapacityRadius)
            } else if (enumStaticSwitchSpike == 2) {
                newCapacityInfo = new ECSCapacityInfo(0, 2, numMolecules)
            } else {
                codeContractViolation()
            }
        } else if (enumPointSphere == 1) {
            newCapacityInfo = new ECSCapacityInfo(1, delta_o)
        } else {
            codeContractViolation()
        }
        
        getSelectedSpeciesName(species)
        
        if (!isSeries_) {
            newECS = new ExtracellularSource(spcCatIdx, species, newSpatialInfo, newTemporalInfo, newCapacityInfo)
        } else {
            newECS = new ExtracellularSource(spcCatIdx, species, newSpatialInfo, newTemporalInfo, newCapacityInfo, seriesInfo)
        }
        
        if (oldSrcIdxOrMinus1 == -1) {
            isUnique = parentWidget.onCreateHandler(newECS)
        } else {
            isUnique = parentWidget.onEditHandler(newECS, oldSrcIdxOrMinus1)
        }
        
        if (!isUnique) {
            return
        }
        
        line1 = "All the changes were saved."
        line2 = "Don't forget to click \"Apply\" in the parent widget."
        mwh.showMessageBox(line1, line2, "Saved")
        
        // !!! just so user can watch colormap dynamics on the PlotShape and create new Graph-s from it
        // dismissHandler()
    }
    
    // !!! BUG: despite this capper, user can make radius_world exactly equal 0 using "Shift" + mouse
    func capRadius() { local radius_world
        radius_world = $1
        
        if (radius_world < float_epsilon) {     // !!! keep the lower bound in sync with proc init
            radius_world = float_epsilon
        }
        
        return radius_world
    }
    
    // This proc can be implemented in different ways depending on what we consider to be the "soma coordinates".
    // In alternative implementations, we can:
    //  * analyze all the points in soma_ref.o(0).sec
    //  * analyze all the sections in soma_ref
    //  * take only one middle point
    //  * calculate the centre of mass (as a weighted sum using diam-s as weight factors)
    // etc.
    proc getSomaCoords() { local n
        soma_ref.o(0).sec {
            n = n3d()
            $&1 = (x3d(0) + x3d(n - 1)) / 2
            $&2 = (y3d(0) + y3d(n - 1)) / 2
            $&3 = (z3d(0) + z3d(n - 1)) / 2
        }
    }
    
    proc createEditBaseConcButtonAndHint() {
        xbutton("* Edit base concentration", "editBaseConcHandler()")
        // !!! maybe move this label to the child widget, then remove "* " above
        xlabel("* Hint: We'll read \"o0\" and ignore \"i0\" var")
    }
    
    proc updateDecks34() { local enumStaticSwitchSpike
        deck3.flip_to(isSeries)
        
        enumStaticSwitchSpike = srcDynamicsList.selected()
        decks4[isSeries].flip_to(enumStaticSwitchSpike)
    }
    
    proc updateDecks67() { local enumStaticSwitchSpike, spcCatIdx, cardIdx, spcNameIdx
        strdef species
        
        enumStaticSwitchSpike = srcDynamicsList.selected()
        if (enumPointSphere == 1 || enumStaticSwitchSpike == 0) {
            deck6.flip_to(0)
            return
        }
        
        spcCatIdx = spcCatsList.selected()
        cardIdx = 1 + spcCatIdx
        deck6.flip_to(cardIdx)
        
        spcNameIdx = spcNamesList.selected()
        cardIdx = spcNameIdx
        decks7[spcCatIdx].flip_to(cardIdx)
    }
    
    proc updateSrcMark() { local x_screen, y_screen
        x_screen = $1
        y_screen = $2
        
        plotShape.erase()
        
        if (enumPointSphere == 0) {
            updatePointMark(x_screen, y_screen)
        } else if (enumPointSphere == 1) {
            updateSphereMark(x_screen, y_screen)
        } else {
            codeContractViolation()
        }
    }
    
    // !!! rename (because it actually creates many markers)
    proc updatePointMark() { local x_screen, y_screen, marker_size
        x_screen = $1
        y_screen = $2
        
        createAllOtherMarks()
        
        marker_size = 8     // !!! hardcode
        plotShape.mark(x_screen, y_screen, "O", marker_size, getColourIdx(), 0)
    }
    
    // !!! rename (because it actually creates many markers)
    proc updateSphereMark() { local x_screen, y_screen, radius_screen, numPts, delta_angle, ptIdx, angle
        x_screen = $1
        y_screen = $2
        
        createAllOtherMarks()
        
        // !!!
        radius_screen = convertRadiusWorldToScreen(radius)  // !!! no need to do this on each mouseEventsHandler
        
        numPts = 200    // !!! hardcode, maybe make it linear to radius_screen
        delta_angle = 2 * PI / numPts
        plotShape.beginline(getColourIdx(), 0)
        for ptIdx = 0, numPts {
            angle = delta_angle * ptIdx
            plotShape.line(x_screen + radius_screen * cos(angle), y_screen + radius_screen * sin(angle))
        }
        
        // An alternative approach
        //     plotShape.mark(x_screen, y_screen, "o", marker_size)
        // looks simpler, but in fact has a restriction ("Arg out of range in user function" if marker_size < 0.1 or > 100)
        // and requires calculation of marker_size which is linear to radius_screen, but also has an unclear dependency on PlotShape zoom, widget size etc.
        
        // !!!! createOrUpdateTempSectionCross()
    }
    
    proc createAllOtherMarks() {
        if (whatToShowIdx == 0) {
            // Empty by design
        } else if (whatToShowIdx == 1) {
            createAllOtherMarksCore(1)
        } else if (whatToShowIdx == 2) {
            createAllOtherMarksCore(0)
        } else {
            codeContractViolation()
        }
    }
    
    proc createAllOtherMarksCore() { local isOnlyOneSpecies, ecsIdx localobj ecsList, otherECS
        strdef species
        
        isOnlyOneSpecies = $1
        
        ecsList = ecsLibrary.ecsList
        getSelectedSpeciesName(species)
        
        for ecsIdx = 0, ecsList.count() - 1 {
            otherECS = ecsList.o(ecsIdx)
            if (ecsIdx == oldSrcIdxOrMinus1 || (isOnlyOneSpecies && !stringsEqual(species, otherECS.species))) {
                continue
            }
            showThisSrc(otherECS.species, otherECS.spatialInfo)
        }
    }
    
    
    
    
    
    // !!!!!!!!!! vvvvvvvvvv just a quick prototype to start with
    
    // !!! think about making all next proc-s members of "ExtracellularSource" or "ExtracellularSourcesLibrary"
    //     (I will have to store one "ExtracellularSource" inside "OneExtracellularSourceWidget")
    
    // !!! similar to updatePlotShape
    proc showThisSrc() { local x_screen, y_screen localobj otherSpatialInfo
        strdef otherSpecies
        
        otherSpecies = $s1
        otherSpatialInfo = $o2
        
        // !!! no need to convert each time user changes species, source shape, sphere radius or whatToShowIdx (just cache it)
        convertCoordsWorldToScreen(otherSpatialInfo.x, otherSpatialInfo.y, otherSpatialInfo.z, &x_screen, &y_screen)
        updateSrcMark2(otherSpecies, otherSpatialInfo, x_screen, y_screen)
    }
    
    // !!! similar to updateSrcMark
    proc updateSrcMark2() { local x_screen, y_screen localobj otherSpatialInfo
        strdef otherSpecies
        
        otherSpecies = $s1
        otherSpatialInfo = $o2
        x_screen = $3
        y_screen = $4
        
        if (otherSpatialInfo.enumPointSphere == 0) {
            updatePointMark2(otherSpecies, x_screen, y_screen)
        } else if (otherSpatialInfo.enumPointSphere == 1) {
            updateSphereMark2(otherSpecies, otherSpatialInfo, x_screen, y_screen)
        } else {
            codeContractViolation()
        }
    }
    
    // !!! similar to updatePointMark
    proc updatePointMark2() { local x_screen, y_screen, marker_size
        strdef otherSpecies
        
        otherSpecies = $s1
        x_screen = $2
        y_screen = $3
        
        marker_size = 8     // !!! hardcode
        plotShape.mark(x_screen, y_screen, "O", marker_size, getColourIdx2(otherSpecies), 0)
    }
    
    // !!! similar to updateSphereMark
    proc updateSphereMark2() { local x_screen, y_screen, radius_screen, numPts, delta_angle, ptIdx, angle localobj otherSpatialInfo
        strdef otherSpecies
        
        otherSpecies = $s1
        otherSpatialInfo = $o2
        x_screen = $3
        y_screen = $4
        
        // !!!
        radius_screen = convertRadiusWorldToScreen(otherSpatialInfo.radiusOrMinus1)     // !!! no need to do this on each mouseEventsHandler
        
        numPts = 200    // !!! hardcode, maybe make it linear to radius_screen
        delta_angle = 2 * PI / numPts
        plotShape.beginline(getColourIdx2(otherSpecies), 0)
        for ptIdx = 0, numPts {
            angle = delta_angle * ptIdx
            plotShape.line(x_screen + radius_screen * cos(angle), y_screen + radius_screen * sin(angle))
        }
        
        // An alternative approach
        //     plotShape.mark(x_screen, y_screen, "o", marker_size)
        // looks simpler, but in fact has a restriction ("Arg out of range in user function" if marker_size < 0.1 or > 100)
        // and requires calculation of marker_size which is linear to radius_screen, but also has an unclear dependency on PlotShape zoom, widget size etc.
    }
    
    // !!! BUG: for colourIdx > 9, we have 2 bad colours and then repetition: 10 - white, 11 - black, 12 - red etc.
    //     but we can install more colours (up to 100):
    //     https://www.neuron.yale.edu/neuron/static/new_doc/visualization/graph.html#Graph.color
    // !!! similar to getColourIdx
    func getColourIdx2() { local otherSpeciesIdx
        strdef otherSpecies
        otherSpecies = $s1
        if (1) {
            // !!! other category - same colours
            otherSpeciesIdx = speciesLibrary.getSpeciesInsideCatIdxForColouring(otherSpecies)
            return 2 + otherSpeciesIdx  // 2: Red
        } else {
            // !!! other category - other colours
            codeContractViolation()
        }
    }
    
    // !!!!!!!!!! ^^^^^^^^^^ just a quick prototype to start with
    
    
    
    
    
    /* !!!!
    // !!! 3D cross made of temporary sections just to test the 2D circle marker positioning.
    //     Once I test that 2D circle and 3D cross are always synced, comment out all the code for the cross
    //     because it affects performance when user interacts with the PlotShape, especially for astrocyte.
    //     After that, maybe draw "x" or "+" with the same colour inside the circle to distinguish it from the other circles shown.
    proc createOrUpdateTempSectionCross() { local test_diam

        create test_sec[3]
        
        // !!! hardcode
        test_diam = 1   // um
        
        test_sec[0] {
            pt3dclear()
            pt3dadd(x - radius, y, z, test_diam)
            pt3dadd(x + radius, y, z, test_diam)
        }
        test_sec[1] {
            pt3dclear()
            pt3dadd(x, y - radius, z, test_diam)
            pt3dadd(x, y + radius, z, test_diam)
        }
        test_sec[2] {
            pt3dclear()
            pt3dadd(x, y, z - radius, test_diam)
            pt3dadd(x, y, z + radius, test_diam)
        }
    }
    
    proc deleteTempSectionCross() { local idx
        for idx = 0, 2 {
            test_sec[idx] delete_section()
        }
    }
    */
    
    // !!! BUG: for colourIdx > 9, we have 2 bad colours and then repetition: 10 - white, 11 - black, 12 - red etc.
    //     but we can install more colours (up to 100):
    //         https://www.neuron.yale.edu/neuron/static/new_doc/visualization/graph.html#Graph.color
    func getColourIdx() { local spcNameIdx, spcCatIdx, spcFlatIdx
        spcNameIdx = spcNamesList.selected()
        if (1) {
            // !!! other category - same colours
            return 2 + spcNameIdx   // 2: Red
        } else {
            // !!! other category - other colours
            spcCatIdx = spcCatsList.selected()
            spcFlatIdx = speciesLibrary.getSpeciesFlatIdxForColouring(spcCatIdx, spcNameIdx)
            return 2 + spcFlatIdx   // 2: Red
        }
    }
    
    // !!! BUG: sometimes the centering and scaling depend on the order of operations in UI:
    //     clicking in parent widget, switching the projection in this widget, moving or resizing the sphere in this widget, changing whatToPlotIdx
    //     (maybe need to call deleteTempSectionCross somewhere)
    proc recenterAndRescalePlotShape() {
        plotShape.exec_menu("View = plot")
    }
    
    proc getSelectedSpeciesName() { local speciesIdx
        speciesIdx = spcNamesList.selected()
        $s1 = spcNamesList.o(speciesIdx).s
    }
    
    // !!! maybe move the next 4 converters to other place
    
    func convertRadiusWorldToScreen() { local radius_world
        radius_world = $1
        return radius_world
    }
    
    func convertRadiusScreenToWorld() { local radius_screen, radius_world
        radius_screen = $1
        radius_world = radius_screen
        radius_world = capRadius(radius_world)  // !!!
        return radius_world
    }
    
    proc convertCoordsWorldToScreen() { local x_world, y_world, z_world
        x_world = $1
        y_world = $2
        z_world = $3
        
        if (viewDirIdx == 0) {
            $&4 = x_world
            $&5 = y_world
        } else if (viewDirIdx == 1) {
            $&4 = z_world
            $&5 = y_world
        } else if (viewDirIdx == 2) {
            $&4 = x_world
            $&5 = z_world
        } else {
            codeContractViolation()
        }
    }
    
    proc convertCoordsScreenToWorld() { local x_screen, y_screen
        x_screen = $1
        y_screen = $2
        
        if (viewDirIdx == 0) {
            $&3 = x_screen
            $&4 = y_screen
        } else if (viewDirIdx == 1) {
            $&4 = y_screen
            $&5 = x_screen
        } else if (viewDirIdx == 2) {
            $&3 = x_screen
            $&5 = y_screen
        } else {
            codeContractViolation()
        }
    }
    
    proc dismissChilds() {
        ionGlobalsWidget.dismissHandler()
        netStimParamsWidget.dismissHandler()
    }
    
endtemplate OneExtracellularSourceWidget
