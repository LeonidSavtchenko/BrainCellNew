
// !! some code dupl. with CreateListOfInputVarsWidget
begintemplate ExtracellularManagerMainWidget

    public show, onCreateHandler, onEditHandler, dismissHandler
    public title
    
    external mwh, ecsLibrary
    external applyExtracellularSources
    external isECSUnique, replaceItemInBrowsedListThenSelect, deleteSelectedItemFromBrowsedList, openDeck, closeDeck, unmapIfNotNil
    external isScheduledRescanningOfDistMechs
    
    objref mainBox, ecsList
    objref oneECSWidget
    objref this
    
    firstColWidth = -1
    secondColWidth = -1
    slotHeight = -1
    
    strdef title
    
    
    proc init() {
        ecsList = ecsLibrary.ecsList
        
        // !!!
        firstColWidth = 345     // !!! make it wider (test on "ExtraIon" sphere series of 100)
        secondColWidth = 115
        slotHeight = 190
        
        title = "Manager of extracellular sources"
        
        oneECSWidget = new OneExtracellularSourceWidget(this)
    }
    
    proc show() { local spacerIdx localobj hBox, deck
        mainBox = new VBox()
        mainBox.intercept(1)
        {
            xpanel("")
            xlabel("Extracellular sources:")
            xpanel()
            hBox = new HBox()
            hBox.intercept(1)
            {
                // It turns out, the usage of two Deck-s with just 1 card below
                // gives a nicer UI compared to other options (VBox, HBox or no-box)
                deck = openDeck()
                {
                    ecsList.browser("", "s")
                    if (ecsList.count() != 0) {
                        ecsList.select(0)
                    }
                    ecsList.accept_action("editHandler()")  // Double click
                }
                closeDeck(deck, 0, firstColWidth, secondColWidth)
                deck = openDeck()
                {
                    xpanel("")
                    xbutton("Create new (default)", "createNewHandler()")
                    xbutton("Copy and edit", "copyAndEditHandler()")
                    xlabel("")
                    xbutton("Edit", "editHandler()")
                    for spacerIdx = 1, 4 {
                        xlabel("")
                    }
                    xbutton("Delete", "deleteHandler()")
                    xpanel()
                }
                closeDeck(deck, 0, secondColWidth, slotHeight)
            }
            hBox.intercept(0)
            hBox.map()
            xpanel("")
            xbutton("Apply", "applyHandler()")
            xpanel()
        }
        mainBox.intercept(0)
        mainBox.dismiss_action("dismissHandler()")
        mainBox.map(title, 110, 150, -1, -1)
    }
    
    func onCreateHandler() { local numECSs localobj newECS
        newECS = $o1
        
        if (!isECSUnique(newECS, ecsList)) {
            return 0
        }
        
        ecsList.append(newECS)
        numECSs = ecsList.count()
        ecsList.select(numECSs - 1)
        
        return 1
    }
    
    func onEditHandler() { local oldSelIdx localobj newECS
        newECS = $o1
        // !!! maybe don't pass oldSelIdx here and just rely on the current selection
        //     (but need to close the child widget if user selects other src in this widget)
        oldSelIdx = $2
        
        if (!isECSUnique(newECS, ecsList)) {
            return 0
        }
        
        replaceItemInBrowsedListThenSelect(ecsList, newECS, oldSelIdx)
        
        return 1
    }
    
    proc dismissHandler() {
        // !!! if there is any unapplied changes, then show a warning and ask whether to apply
        dismissChild()
        unmapIfNotNil(mainBox)
    }
    
    // All next staff is private
    
    
    proc createNewHandler() {
        dismissChild()
        oneECSWidget.show()     // --> onCreateHandler
    }
    
    proc copyAndEditHandler() { local selIdxOrMinus1 localobj oldECS
        selIdxOrMinus1 = prologue4Show4NotNew(oldECS)
        if (selIdxOrMinus1 == -1) {
            return
        }
        
        oneECSWidget.show(oldECS)   // --> onCreateHandler
    }
    
    proc editHandler() { local selIdxOrMinus1 localobj oldECS
        selIdxOrMinus1 = prologue4Show4NotNew(oldECS)
        if (selIdxOrMinus1 == -1) {
            return
        }
        
        oneECSWidget.show(oldECS, selIdxOrMinus1)   // --> onEditHandler
    }
    
    proc deleteHandler() {
        dismissChild()
        deleteSelectedItemFromBrowsedList(ecsList)
    }
    
    proc applyHandler() {
        strdef line1, line2, line3, line4, line5
        
        // !!! just so user can watch colormap dynamics on the PlotShape and create new Graph-s from it
        // dismissChild()
        
        // !!! say "No changes" or "All deleted" when that's the case
        
        // !!!! think about FInitializeHandler
        applyExtracellularSources()
        
        // !!! for higher performance, think about rescanning only a subset of mechs,
        //     however, we've called "init", so changes in "*o" ion vars could propagate to arbitrary other mech vars
        isScheduledRescanningOfDistMechs = 1
        
        oneECSWidget.onApplyInParentWidget()
        
        // !!! just for test (without this, the PlotShape-s created in "init_ExtraManager.hoc" are not updated after user clicks "Apply")
        if (name_declared("testPlotShape1")) {
            execute("testPlotShape1.flush()")   // !!! .fastflush() works as well
        }
        if (name_declared("testPlotShape2")) {
            execute("testPlotShape2.flush()")
        }
        if (name_declared("testPlotShape3")) {
            execute("testPlotShape3.flush()")
        }
        
        line1 = "All the changes were applied."
        
        // !!! if RunControl works fine, then we don't need to show AltRunControl together with this widget
        line2 = "Now you can start the simulation with either RunControl or AltRunControl."
        
        // !!! instead of "{species}o", show the list of actual species names from ecsList
        line3 = "Make sure you don't use any biophys mechs that write the same \"{species}o\" vars to avoid collisions."
        
        // !!! when user clicks "Apply", then increases "nseg" in any section and then starts the simulation without clicking "Apply" once again,
        //     this expectedly results in "Segmentation violation"
        //     to avoid this, we'll have to stick to AltRunControl only and "click" "Apply" programmatically on start of the simulation
        //     alternatively, we can save "total_nseg" in MOD file on "Apply", then check it each time user starts the simulation and,
        //     if we see that it's different, print a message to console suggesting to click "Apply"
        line4 = "If you modify the cell geometry or move it in 3D space, change \"nseg\" somewhere or add new sections,"
        
        sprint(line5, "then get back to the \"%s\" and click \"Apply\" once again.", title)
        
        mwh.showMessageBox(line1, line2, "", line3, line4, line5, "Applied")
    }
    
    proc dismissChild() {
        // !!! if there is any unapplied changes, then ask whether to apply them
        oneECSWidget.dismissHandler()
    }
    
    func prologue4Show4NotNew() { local selIdx
        dismissChild()
        
        selIdx = ecsList.selected()
        if (selIdx == -1) {
            return -1
        }
        
        $o1 = ecsList.o(selIdx)
        return selIdx
    }
    
endtemplate ExtracellularManagerMainWidget
