
{ load_file("Exported/InterModularSectionUtils_Exported.hoc") }


// Get the name of the currently accessed section (either object name or array name)
// Does not work if the section owned by a template!!
// $s1 (output) - The section name
proc getCurrentSecName() { local idx localobj strFunc
    strdef secName
    
    strFunc = new StringFunctions()
    
    idx = strFunc.head(secname(), "\\[", secName)
    if (idx == -1) {
        // This section is an object rather than array
        secName = secname()
    }
    
    $s1 = secName
}

// Get names of all created sections (either object name or array name)
// Does not work if there is a section owned by a template!!
// Returns List of String-s containing all unique names
obfunc getAllSectionNames() { local idxOrMinus1 localobj secNames
    strdef secName
    
    secNames = new List()
    
    forall {
        getCurrentSecName(secName)
        
        // Check if we have found this name before
        // !! improve performace here using Set in Python
        idxOrMinus1 = findItemInListByString(secNames, secName)
        
        if (idxOrMinus1 == -1) {
            secNames.append(new String(secName))
        }
    }
    
    return secNames
}

// !!! the range returned by this func depends on the initial segmentation;
//     do I need to apply some default segmentation before calling it?
func getDistRangeGivenSections() { local distMin, distMax, isDisconnected, x, dist localobj list_ref
    
    list_ref = $o1
    
    distMin = math.inf
    distMax = -1
    
    isDisconnected = 0
    // We could check just 2 end points for each section for higher performance,
    // but there is no guarantee that the distance centre was not placed somewhere in this compartment inside a section
    for eachSecInList(list_ref) {
        for (x) {
            dist = distance(x)
            if (dist == 1e20) { // NEURON docs read: "If a continuous path does not exist the return value is 1e20"
                isDisconnected = 1
                break
            }
            math.updateMinMax(&distMin, &distMax, dist)
        }
    }
    
    if (isDisconnected) {
        return 1
    }
    
    $&2 = distMin
    $&3 = distMax
    
    return 0
}

// For all sections from this SectionList, add corresponding SectionRef to the List
// $o1 - The SectionList
// $o2 - The List
proc secListToListOfSecRef() { localobj secList, list_ref
    secList = $o1
    list_ref = $o2
    forsec secList {
        list_ref.append(new SectionRef())
    }
}

obfunc listOfSecRefToSecList() { localobj list_ref, secList
    list_ref = $o1
    secList = new SectionList()
    for eachSecInList(list_ref) {
        secList.append()
    }
    return secList
}

func capDiam() {
    // If user sets too small "diam" for a section, NEURON resets it to 1e-9 when user enters
    //  Tools -> Distributed Mechanisms -> Viewers -> Shape Name
    // and then double clicks on a section in the list.
    // So we cap "diam" in advance just to avoid the unexpected behaviour later.
    return math.max($1, 1e-9)
}

// Delete all sections
// (The names remain declared and cannot be used for anything else than creating new sections and section arrays)
proc deleteAllSections() {
    forall {
        delete_section()
    }
}
