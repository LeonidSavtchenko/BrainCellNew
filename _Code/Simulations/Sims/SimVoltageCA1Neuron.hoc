
// !!!! currently we use the path between soma_ref.o(0).sec(0.5) (the distance centre) and the most proximal segment in dendrite_ref,
//      but it would be better to implement it in the different way:
//      * find the most proximal point in "ProxyDendrit" comp;
//      * find the most proximal point in "DistalDendrite" comp;
//      * (if no such comps, then fallback to the current algorithm);
//      * get all sections in the path between these two extreme points using _rangeVarPlot.list;
//      * create equidistant grid between the points along the path and watch voltage in the grid points;
//      * add one more special point for soma_ref.o(0).sec(0.5) to watch voltage as well

// !!! add coloured markers on pathPlotShape indicating the observation points
// !!! add vertical coloured lines on rangeGraph indicating the observation points

// !!! maybe move the file to "Neuron" subfolder?

// !!! keeping it on the top level to be accessible from "execute"-ed HOC command
objref _rangeVarPlot

begintemplate SimVoltageCA1Neuron
    
    public show, dismissHandler
    public biophysJsonFileNameOrEmpty, isCustomProcAdvance
    
    external getDistRangeGivenSections, addVarToGraph, removeItemFromList, unmapIfNotNil, codeContractViolation
    external math, mwh
    external eachPointInGrid, eachSegmInSecList
    external soma_ref, dendrite_ref
    external pyObj
    external graphList, flush_list
    external tstop
    external _rangeVarPlot
    
    strdef biophysJsonFileNameOrEmpty
    isCustomProcAdvance = -1
    objref timeGraphBox, pathAndRangeBox
    objref timeGraph, rangeGraph
    
    
    proc init() {
        biophysJsonFileNameOrEmpty = "SimVoltageCA1Neuron.json"
        isCustomProcAdvance = 0
    }
    
    proc show() { localobj pathPlotShape
        
        timeGraphBox = new VBox()
        timeGraphBox.intercept(1)
        {
            timeGraph = new Graph()
        }
        timeGraphBox.intercept(0)
        timeGraphBox.map("Time-Voltage graph", 10, 10, -1, -1)
        
        pathAndRangeBox = new HBox()
        pathAndRangeBox.intercept(1)
        {
            pathPlotShape = new PlotShape()
            rangeGraph = new Graph()
        }
        pathAndRangeBox.intercept(0)
        pathAndRangeBox.map("Path plot and Range-Voltage graph", 420, 10, -1, -1)
        
        showCore(pathPlotShape)
    }
    
    proc dismissHandler() {
        
        removeItemFromList(graphList[0], timeGraph)
        removeItemFromList(flush_list, rangeGraph)
        
        unmapIfNotNil(timeGraphBox)
        unmapIfNotNil(pathAndRangeBox)
    }
    
    // All next staff is private
    
    
    proc showCore() { local colourIdx, numDendPts, dist_max, y_min, y_max localobj pathPlotShape, pyVarsSet, pathSecList
        strdef var
        
        pathPlotShape = $o1
        
        // pathPlotShape.menu_remove("3D Rotate")   // !!! error here: menu_remove not a public member of PlotShape
        pathPlotShape.color_all(9)                  // Grey
        
        pyVarsSet = pyObj.set()
        _rangeVarPlot = new RangeVarPlot("v")
        
        // !!!! move the legend to the top-right corner
        
        soma_ref.o(0).sec {
            sprint(var, "%s.v(0.5)", secname())
            pyVarsSet.add(var)
            _rangeVarPlot.begin(0.5)
        }
        colourIdx = 2   // Red      !!! maybe use Blue here not to confuse with pathPlotShape and rangeGraph palette
        /* !!!!
        getSegmXYZ(secName, 0.5, &x, &y, &z)
        pathPlotShape.mark(x, y, "o", colourIdx)
        */
        addVarToGraph(timeGraph, var, colourIdx)
        colourIdx += 1
        numDendPts = 5
        dist_max = addPointsForVoltageInDendrites(pathPlotShape, timeGraph, colourIdx, numDendPts, pyVarsSet)
        if (dist_max == -1) {
            return
        }
        y_min = -80
        y_max = 40
        timeGraph.size(0, tstop, y_min, y_max)
        setXYLabels(timeGraph, "Time (ms)")
        graphList[0].append(timeGraph)
        
        rangeGraph.addobject(_rangeVarPlot, 2, 0)    // Red
        rangeGraph.size(0, dist_max, y_min, y_max)
        setXYLabels(rangeGraph, "Distance (um)")
        flush_list.append(rangeGraph)
        
        // !!!!! how about _rangeVarPlot.origin() ?
        
        pathSecList = new SectionList()
        _rangeVarPlot.list(pathSecList)
        pathPlotShape.color_list(pathSecList, 2)    // Red
    }
    
    // Here we choose some pretty random points on dendrites equidistantly spaced by "distance" ("numDendPts" points in total);
    // !!! an alternative implementation may choose "numDendPts" farthest from each other points on dendrites (using the graph theory)
    // !!! for numDendPts > 7, we have 2 bad colours and then repetition of colours: colourIdx = 10 is white, colourIdx = 11 is black, colourIdx = 12 is red etc.
    func addPointsForVoltageInDendrites() { local colourIdx, numDendPts, isDisconnected, dist_min, dist_max, u, isFirstPoint, dist localobj pyVarsSet, timeGraph, pathPlotShape
        strdef sec_name, var, hocCommand
        
        pathPlotShape = $o1
        timeGraph = $o2
        colourIdx = $3
        numDendPts = $4
        pyVarsSet = $o5
        
        isDisconnected = getDistRangeGivenSections(dendrite_ref, &dist_min, &dist_max)
        if (isDisconnected) {
            mwh.showWarningBox("Cannot proceed with this simulation because at least one dendrite section doesn't have a topological connection with the distance centre.")
            return -1
        }
        
        u = -1
        
        isFirstPoint = 1
        for eachPointInGrid(&dist, dist_min, dist_max, numDendPts + 1) {
            if (isFirstPoint) {
                // We have used soma_ref.o(0).sec(0.5) as the first watched point being also the distance centre
                isFirstPoint = 0
                continue
            }
            u = findSecAndSegmInDendrites(dist, sec_name)
            sprint(var, "%s.v(%g)", sec_name, u)
            if (pyObj.isInPySet(pyVarsSet, var)) {
                continue    // !!! maybe it would be better to get back to findSecAndSegmInDendrites and find the next candidate
            }
            /* !!!!
            getSegmXYZ(secName, u, &x, &y, &z)
            pathPlotShape.mark(x, y, "o", colourIdx)
            */
            addVarToGraph(timeGraph, var, colourIdx)
            pyVarsSet.add(var)
            colourIdx += 1
        }
        
        if (u == -1) {
            // !!!
            codeContractViolation()
        }
        
        sprint(hocCommand, "access %s { _rangeVarPlot.end(%s) }", sec_name, pyObj.str(u))
        execute(hocCommand)
        
        return dist_max
    }
    
    func findSecAndSegmInDendrites() { local dist_exp, delta_best, u_best, u, dist, delta
        strdef sec_name
        
        dist_exp = $1
        
        delta_best = math.inf
        u_best = -1
        
        for eachSegmInSecList(&u, dendrite_ref) {
            dist = distance(u)
            delta = abs(dist - dist_exp)
            if (delta < delta_best) {
                sec_name = secname()
                u_best = u
                delta_best = delta
            }
        }
        
        if (u_best == -1) {
            // !!!!!
            codeContractViolation()
        }
        
        $s2 = sec_name
        
        return u_best
    }
    
    proc setXYLabels() { localobj graph
        strdef x_label
        graph = $o1
        x_label = $s2
        graph.label(0.44, 0.015, x_label)
        graph.label(0.04, 0.95, "Voltage (mV)")
    }
    
endtemplate SimVoltageCA1Neuron
