
userDefinedHocDistFuncArgument = -1
userDefinedHocDistFuncResult = -1

begintemplate CustomCodeDistFuncHelper

    public selectedHandler, calculateAt, onJustBeforeFirstSection, onJustBeforeNewSection, onJustAfterLastSection, exportParams, importParams, dismissHandler
    public parentWidget, isSkipOneSelect
    public modelIdx     // For CodeFromFileDistFuncHelper
    
    external codeContractViolation, printMsgAndRaiseError, printNotImplementedMsgAndRaiseError
    external pyObj
    external userDefinedHocDistFuncArgument, userDefinedHocDistFuncResult
    
    objref parentWidget, this
    
    modelIdx = -1
    strdef oneLinerHocDistFuncName, oneLinerHocDistFuncBody
    strdef oneLinerPyDistFuncName, oneLinerPyDistFuncBody
    strdef userDefinedHocDistFuncName, userDefinedPyDistFuncName
    
    isSkipOneSelect = -1
    
    
    proc init() { local numArg
    
        numArg = numarg()
        
        if (numArg == 0) {
            // Empty by design (we are being created in the exported HOC file or in the process of biophys JSON import,
            // so will be inited in proc importParams shortly downstream)
        } else if (numArg == 1) {
            setModelIdx($1)
            
            oneLinerHocDistFuncName = "mechManagerOneLinerHocDistFunc"
            oneLinerHocDistFuncBody = "x/10 + 50*sin(2*PI*x/200) * tanh(x/100)"
            
            oneLinerPyDistFuncName = "mechManagerOneLinerPyDistFunc"
            oneLinerPyDistFuncBody = "x/10 + 50*sin(2*pi*x/200) * tanh(x/100)"
            
            userDefinedHocDistFuncName = "myDistFunc"
            userDefinedPyDistFuncName = "myDistFunc"
        } else {
            codeContractViolation()
        }
        
        isSkipOneSelect = 0
    }
    
    func selectedHandler() { local numArg, isJustLoaded, isAccept
        strdef hocCommand, hint1, hint2, text
        
        if (isSkipOneSelect) {
            isSkipOneSelect = 0
            return 0
        }
        
        numArg = numarg()
        if (numArg == 0) {
            isJustLoaded = 0
        } else if (numArg == 1) {
            isJustLoaded = $1
        } else {
            codeContractViolation()
        }
        
        hint1 = " The expression must depend on \"x\"."
        if (!isJustLoaded) {
            hint2 = " (We assume you've defined the function in console manually or loaded from file.)"
        } else {
            hint2 = ""
        }
        
        if (modelIdx == 0) {
            sprint(text, "Enter HOC expression (one-liner).%s", hint1)
            isAccept = string_dialog(text, oneLinerHocDistFuncBody)
            if (!isAccept) {
                return 1
            }
            defineHocFunction(oneLinerHocDistFuncName, oneLinerHocDistFuncBody)
        } else if (modelIdx == 1) {
            sprint(text, "Enter Python expression (one-liner).%s We've done \"from math import *\" for you.", hint1)
            isAccept = string_dialog(text, oneLinerPyDistFuncBody)
            if (!isAccept) {
                return 1
            }
            definePythonFunction(oneLinerPyDistFuncName, oneLinerPyDistFuncBody)
        } else if (modelIdx == 2) {
            sprint(text, "Enter name of your HOC function. $1 is x, return is y.%s", hint2)
            isAccept = string_dialog(text, userDefinedHocDistFuncName)
            if (!isAccept) {
                return 1
            }
        } else if (modelIdx == 3) {
            sprint(text, "Enter name of your Python function. The input argument is x, return is y.%s", hint2)
            isAccept = string_dialog(text, userDefinedPyDistFuncName)
            if (!isAccept) {
                return 1
            }
        } else {
            codeContractViolation()
        }
        
        return 0
    }
    
    func calculateAt() { local x
        x = $1
        
        if (modelIdx == 0) {
            return mechManagerOneLinerHocDistFunc(x)
        } else if (modelIdx == 1) {
            return callPythonFunction(oneLinerPyDistFuncName, x)
        } else if (modelIdx == 2) {
            return callUserDefinedHocDistFunc(userDefinedHocDistFuncName, x)
        } else if (modelIdx == 3) {
            return callPythonFunction(userDefinedPyDistFuncName, x)
        } else {
            codeContractViolation()
        }
    }
    
    proc onJustBeforeFirstSection() {
        // Empty by design
    }
    
    proc onJustBeforeNewSection() {
        // Empty by design
    }
    
    proc onJustAfterLastSection() {
        // Empty by design
    }
    
    proc exportParams() { localobj vecOfVals, listOfStrs
        vecOfVals = $o1
        listOfStrs = $o2
        
        if (modelIdx == 2 || modelIdx == 3) {
            printNotImplementedMsgAndRaiseError("Cannot export \"Custom function\" inhomogeneity model.")
        }
        
        vecOfVals.resize(1)
        vecOfVals.x(0) = modelIdx
        listOfStrs.append(new String(oneLinerHocDistFuncName))
        listOfStrs.append(new String(oneLinerHocDistFuncBody))
        listOfStrs.append(new String(oneLinerPyDistFuncName))
        listOfStrs.append(new String(oneLinerPyDistFuncBody))
        listOfStrs.append(new String(userDefinedHocDistFuncName))
        listOfStrs.append(new String(userDefinedPyDistFuncName))
    }
    
    proc importParams() { localobj vecOfVals, listOfStrs
        vecOfVals = $o1
        listOfStrs = $o2
        
        if (vecOfVals.size() != 1 || listOfStrs.count() != 6) {
            codeContractViolation()
        }
        
        setModelIdx(vecOfVals.x(0))
        oneLinerHocDistFuncName = listOfStrs.o(0).s
        oneLinerHocDistFuncBody = listOfStrs.o(1).s
        oneLinerPyDistFuncName = listOfStrs.o(2).s
        oneLinerPyDistFuncBody = listOfStrs.o(3).s
        userDefinedHocDistFuncName = listOfStrs.o(4).s
        userDefinedPyDistFuncName = listOfStrs.o(5).s
        
        if (modelIdx == 0) {
            defineHocFunction(oneLinerHocDistFuncName, oneLinerHocDistFuncBody)
        } else if (modelIdx == 1) {
            definePythonFunction(oneLinerPyDistFuncName, oneLinerPyDistFuncBody)
        } else {
            codeContractViolation()
        }
    }
    
    proc dismissHandler() {
        // Empty by design
    }
    
    // All next staff is private
    
    
    func mechManagerOneLinerHocDistFunc() { codeContractViolation() }
    
    proc defineHocFunction() { local isSuccess
        strdef oneLinerHocDistFuncName, oneLinerHocDistFuncBody, hocCommand
        
        oneLinerHocDistFuncName = $s1
        oneLinerHocDistFuncBody = $s2
        
        sprint(hocCommand, "func %s() { local x\nx = $1\nreturn %s }", oneLinerHocDistFuncName, oneLinerHocDistFuncBody)
        isSuccess = execute1(hocCommand, this)
        // !! BUG: something is wrong with error hendling here, e.g. user can enter "1x" and get no error
        if (!isSuccess) {
            printMsgAndRaiseError("Failed to define the function. Please check the syntax.")
        }
    }
    
    func callUserDefinedHocDistFunc() {
        strdef userDefinedHocDistFuncName, hocCommand
        
        userDefinedHocDistFuncName = $s1
        userDefinedHocDistFuncArgument = $2
        
        // !! try to invent a better way to call a top-level func encapsulating both x and y into this template;
        //    think about push_object in HOC or hocObj.* in Python or execute(*, this) in HOC
        sprint(hocCommand, "userDefinedHocDistFuncResult = %s(userDefinedHocDistFuncArgument)", userDefinedHocDistFuncName)
        execute(hocCommand)
        
        return userDefinedHocDistFuncResult
    }
    
    proc definePythonFunction() { local status
        strdef oneLinerPyDistFuncName, oneLinerPyDistFuncBody, pyCommand
        
        oneLinerPyDistFuncName = $s1
        oneLinerPyDistFuncBody = $s2
        
        sprint(pyCommand, "from math import *\ndef %s(x):\n    return %s", oneLinerPyDistFuncName, oneLinerPyDistFuncBody)
        status = nrnpython(pyCommand)
        if (!status) {
            // !!!!! printPythonErrMsgAndStop
            printMsgAndRaiseError("Exception raised in Python code (caught in definePythonFunction)")
        }
    }
    
    func callPythonFunction() { local x, status
        strdef oneLinerPyDistFuncName, pyCommand
        
        oneLinerPyDistFuncName = $s1
        x = $2
        
        pyObj.x = x
        
        sprint(pyCommand, "y = %s(x)", oneLinerPyDistFuncName)
        status = nrnpython(pyCommand)
        if (!status) {
            // !!!!! printPythonErrMsgAndStop
            printMsgAndRaiseError("Exception raised in Python code (caught in callPythonFunction)")
        }
        
        return pyObj.y
    }
    
    proc setModelIdx() {
        modelIdx = $1
        if (modelIdx < 0 || modelIdx > 3) {
            codeContractViolation()
        }
    }
    
endtemplate CustomCodeDistFuncHelper
