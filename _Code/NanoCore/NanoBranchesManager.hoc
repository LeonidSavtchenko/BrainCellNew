
// The next "declarations" are needed just to bind the template external-s at the file sourcing time
//  Only one of these two will be defined and used
obfunc createNeuronNanoBranch() { codeContractViolation() }
obfunc createAstrocyteNanoBranch() { codeContractViolation() }
//  These proc-s will be defined after the file sourcing and before the first call
proc Neuron_AddSynapses_reseed() { codeContractViolation() }
proc Neuron_AddSynapses_delete() { codeContractViolation() }

objref manageAndRunWidget

// !!
isFirstReseeding = 1

NumberNanoBranches = -1

{ load_file("Exported/CreateNanoRefs_Exported.hoc") }

if (isAstrocyteOrNeuron) {
    load_file("Astrocyte/AstrocyteNanoBranch.hoc")
    objref spineNeckDiamCache
} else {
    load_file("Neuron/NeuronNanoBranch.hoc")
    load_file("../Managers/SynManager/Exported/SpineNeckDiamCache.hoc")
}


begintemplate NanoBranchesManager
    
    public reseedBranches, reseedBranchesWithLastUsedArgs, updateBranches, deleteBranches
    
    // Keeping this list "public" even though the name doesn't appear explicitly anywhere outside this template.
    // It turns out, NEURON accesses it via reflection (implicitly) when user selects
    //  Tools -> Distributed Mechanisms -> Viewers -> Shape Name
    // and then double clicks on any nanogeometry section in the list.
    public nanoBranches_flat
    
    public MaxNumberBranchesPerDendrite
    
    external seededDendrite_ref, NumberNanoBranches
    external isAstrocyteOrNeuron, MinDistance, MaxDendriticLength, isFirstReseeding
    external mwh, rngUtils, math
    external eachItemInList
    external manageAndRunWidget
    
    external createAstrocyteNanoBranch, createNeuronNanoBranch, createRefsForNanoGeometry
    external spineNeckDiamCache, Neuron_AddSynapses_reseed, Neuron_AddSynapses_delete
    external initVoltage
    
    objref nanoBranches_flat    // !! Flat List of all AstrocyteNanoBranch or NeuronNanoBranch -- need to merge this with the logic from Exported/CreateNanoRefs_Exported.hoc !!
    objref randomBranchSeeder 
    
    MaxNumberBranchesPerDendrite = -1
    
    objref lastUsedArgs
    
    
    // Initialization of this singleton template
    proc init() { local inf
        MaxNumberBranchesPerDendrite = $1
        
        nanoBranches_flat = new List()
        randomBranchSeeder = rngUtils.getFor_branchSeeder()
        
        inf = math.inf
        variable_domain(&MaxNumberBranchesPerDendrite, 0, inf)
    }
    
    // Reseed dendrites with nanobranches
    // $o1 - The Vector of args passed to *NanoBranch template
    // Other inputs: seededDendrite_ref (taken from the top level) etc.
    proc reseedBranches() { local ControlFactor, NormFactor, slotIdx localobj args, nil, sec_ref
        args = $o1
        
        lastUsedArgs = args
        
        if (manageAndRunWidget != nil) {
            manageAndRunWidget.onNanoReseedOrUpdateHandler()
        }
        
        mwh.showPleaseWaitBox("Reseeding nanostructures.")
        {
            if (!isFirstReseeding) {
                deleteBranches()
            }
            
            ControlFactor=(MinDistance*MaxNumberBranchesPerDendrite)/MaxDendriticLength
            
            // !!! maybe use eachSecInList here
            for eachItemInList(sec_ref, seededDendrite_ref) {
                NormFactor=ControlFactor*MaxDendriticLength/sec_ref.sec.L
                
                for slotIdx = 0, MaxNumberBranchesPerDendrite - 1 {
                    
                    if (randomBranchSeeder.uniform(0,1) < 1/NormFactor) {
                        createInitAndConnectOneBranch(sec_ref, slotIdx, args)
                    }
                }
            }
            
            // !! is this correct place?
            // !! maybe it would be easier to collect references while creating sections rather than search for sections with regex afterwards
            createRefsForNanoGeometry()
            
            // !! it would be better to init the voltage just in nanogeometry
            initVoltage()
            
            if (!isAstrocyteOrNeuron) {
                spineNeckDiamCache.cacheAllDiams()
                if (!isFirstReseeding) {
                    Neuron_AddSynapses_reseed()
                }
            }
        }
        mwh.hidePleaseWaitBox()
        
        isFirstReseeding = 0
        NumberNanoBranches = nanoBranches_flat.count()
        
        print "NumberNanoBranches: ", NumberNanoBranches    // !!!!
    }
    
    // Reseed dendrites with nanobranches using the same arguments as the last time
    // Inputs: seededDendrite_ref (taken from the top level) etc.
    proc reseedBranchesWithLastUsedArgs() {
        reseedBranches(lastUsedArgs)
    }
    
    // Update nanobranches geometry without reseeding
    // $o1 - The Vector of args passed to *NanoBranch template
    proc updateBranches() { localobj args, nil, nanoBranch
        args = $o1
        
        if (manageAndRunWidget != nil) {
            manageAndRunWidget.onNanoReseedOrUpdateHandler()
        }
        
        for eachItemInList(nanoBranch, nanoBranches_flat) {
            nanoBranch.update(args)
        }
        
        if (!isAstrocyteOrNeuron) {
            spineNeckDiamCache.cacheAllDiams()
        }
    }
    
    // Delete all nanobranches
    proc deleteBranches() {
        // !! would it make sense to add some validation code to unref() procs of the destructed templates to check whether something external is connected?
        nanoBranches_flat.remove_all()
        
        // !! maybe clean up all refs to nanogeometry here just for safety
        
        if (!isAstrocyteOrNeuron) {
            Neuron_AddSynapses_delete()
        }
    }
    
    // All next staff is private
    
    
    // Create, initialize and connect to dendrite a new nanobranch
    // $o1 - The SectionRef of the seeded dendrite
    // $2 - The index of a slot on that dendrite to connect the new nanobranch
    // $o3 - The Vector of args passed to *NanoBranch template
    // Other inputs: seededDendrite_ref (taken from the top level) etc.
    proc createInitAndConnectOneBranch() { local slotIdx, connectionPoint localobj sec_ref, args, newBranch
        sec_ref = $o1
        slotIdx = $2
        args = $o3
        
        // Create and initialize one branch (sections, topology, geometry, biophysics)
        if (isAstrocyteOrNeuron) {
            newBranch = createAstrocyteNanoBranch(args)
        } else {
            newBranch = createNeuronNanoBranch(args)
        }
        nanoBranches_flat.append(newBranch)
        
        // Connect the new branch to this dendrite in this point
        connectionPoint = (1/MaxNumberBranchesPerDendrite)*slotIdx
        sec_ref.sec connect newBranch.root_ref.sec(0), connectionPoint
    }
    
endtemplate NanoBranchesManager
